/* automatically generated by rust-bindgen */

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const FONTMETRICS_FLAGS_UNDERLINE_THICKNESS_IS_VALID: u32 = 1;
pub const FONTMETRICS_FLAGS_UNDERLINE_POSITION_IS_VALID: u32 = 2;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
#[doc = ""]
pub type sk_color_t = u32;
pub type sk_pmcolor_t = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_colortype_t {
    UNKNOWN_SK_COLORTYPE = 0,
    ALPHA_8_SK_COLORTYPE = 1,
    RGB_565_SK_COLORTYPE = 2,
    ARGB_4444_SK_COLORTYPE = 3,
    RGBA_8888_SK_COLORTYPE = 4,
    RGB_888X_SK_COLORTYPE = 5,
    BGRA_8888_SK_COLORTYPE = 6,
    RGBA_1010102_SK_COLORTYPE = 7,
    RGB_101010X_SK_COLORTYPE = 8,
    GRAY_8_SK_COLORTYPE = 9,
    RGBA_F16_SK_COLORTYPE = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_alphatype_t {
    UNKNOWN_SK_ALPHATYPE = 0,
    OPAQUE_SK_ALPHATYPE = 1,
    PREMUL_SK_ALPHATYPE = 2,
    UNPREMUL_SK_ALPHATYPE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_pixelgeometry_t {
    UNKNOWN_SK_PIXELGEOMETRY = 0,
    RGB_H_SK_PIXELGEOMETRY = 1,
    BGR_H_SK_PIXELGEOMETRY = 2,
    RGB_V_SK_PIXELGEOMETRY = 3,
    BGR_V_SK_PIXELGEOMETRY = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_surfaceprops_flags_t {
    USE_DEVICE_INDEPENDENT_FONTS_SK_SURFACE_PROPS_FLAGS = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_surfaceprops_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_point_t {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_sk_point_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_point_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_point_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_point_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_point_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_point_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_point_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point_t),
            "::",
            stringify!(y)
        )
    );
}
pub type sk_vector_t = sk_point_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_irect_t {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[test]
fn bindgen_test_layout_sk_irect_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_irect_t>(),
        16usize,
        concat!("Size of: ", stringify!(sk_irect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_irect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_irect_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_irect_t>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_irect_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_irect_t>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_irect_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_irect_t>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_irect_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_irect_t>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_irect_t),
            "::",
            stringify!(bottom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_rect_t {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[test]
fn bindgen_test_layout_sk_rect_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_rect_t>(),
        16usize,
        concat!("Size of: ", stringify!(sk_rect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_rect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_rect_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_rect_t>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rect_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_rect_t>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rect_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_rect_t>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rect_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_rect_t>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rect_t),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = "The sk_matrix_t struct holds a 3x3 perspective matrix for"]
#[doc = "transforming coordinates:"]
#[doc = ""]
#[doc = "(X,Y) = T[M]((x,y))"]
#[doc = "X = (M[0] * x + M[1] * y + M[2]) / (M[6] * x + M[7] * y + M[8]);"]
#[doc = "Y = (M[3] * x + M[4] * y + M[5]) / (M[6] * x + M[7] * y + M[8]);"]
#[doc = ""]
#[doc = "Therefore, the identity matrix is"]
#[doc = ""]
#[doc = "sk_matrix_t identity = {{1, 0, 0,"]
#[doc = "0, 1, 0,"]
#[doc = "0, 0, 1}};"]
#[doc = ""]
#[doc = "A matrix that scales by sx and sy is:"]
#[doc = ""]
#[doc = "sk_matrix_t scale = {{sx, 0,  0,"]
#[doc = "0,  sy, 0,"]
#[doc = "0,  0,  1}};"]
#[doc = ""]
#[doc = "A matrix that translates by tx and ty is:"]
#[doc = ""]
#[doc = "sk_matrix_t translate = {{1, 0, tx,"]
#[doc = "0, 1, ty,"]
#[doc = "0, 0, 1}};"]
#[doc = ""]
#[doc = "A matrix that rotates around the origin by A radians:"]
#[doc = ""]
#[doc = "sk_matrix_t rotate = {{cos(A), -sin(A), 0,"]
#[doc = "sin(A),  cos(A), 0,"]
#[doc = "0,       0,      1}};"]
#[doc = ""]
#[doc = "Two matrixes can be concatinated by:"]
#[doc = ""]
#[doc = "void concat_matrices(sk_matrix_t* dst,"]
#[doc = "const sk_matrix_t* matrixU,"]
#[doc = "const sk_matrix_t* matrixV) {"]
#[doc = "const float* u = matrixU->mat;"]
#[doc = "const float* v = matrixV->mat;"]
#[doc = "sk_matrix_t result = {{"]
#[doc = "u[0] * v[0] + u[1] * v[3] + u[2] * v[6],"]
#[doc = "u[0] * v[1] + u[1] * v[4] + u[2] * v[7],"]
#[doc = "u[0] * v[2] + u[1] * v[5] + u[2] * v[8],"]
#[doc = "u[3] * v[0] + u[4] * v[3] + u[5] * v[6],"]
#[doc = "u[3] * v[1] + u[4] * v[4] + u[5] * v[7],"]
#[doc = "u[3] * v[2] + u[4] * v[5] + u[5] * v[8],"]
#[doc = "u[6] * v[0] + u[7] * v[3] + u[8] * v[6],"]
#[doc = "u[6] * v[1] + u[7] * v[4] + u[8] * v[7],"]
#[doc = "u[6] * v[2] + u[7] * v[5] + u[8] * v[8]"]
#[doc = "}};"]
#[doc = "dst = result;"]
#[doc = "}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_matrix_t {
    pub mat: [f32; 9usize],
}
#[test]
fn bindgen_test_layout_sk_matrix_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_matrix_t>(),
        36usize,
        concat!("Size of: ", stringify!(sk_matrix_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_matrix_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_matrix_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_matrix_t>())).mat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(mat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_matrix44_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_matrix44_type_mask_t {
    IDENTITY_SK_MATRIX44_TYPE_MASK = 0,
    TRANSLATE_SK_MATRIX44_TYPE_MASK = 1,
    SCALE_SK_MATRIX44_TYPE_MASK = 2,
    AFFINE_SK_MATRIX44_TYPE_MASK = 4,
    PERSPECTIVE_SK_MATRIX44_TYPE_MASK = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_nodraw_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_nway_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_overdraw_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_data_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_drawable_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_image_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_maskfilter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_paint_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_picture_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_picture_recorder_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_shader_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_surface_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_region_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_blendmode_t {
    CLEAR_SK_BLENDMODE = 0,
    SRC_SK_BLENDMODE = 1,
    DST_SK_BLENDMODE = 2,
    SRCOVER_SK_BLENDMODE = 3,
    DSTOVER_SK_BLENDMODE = 4,
    SRCIN_SK_BLENDMODE = 5,
    DSTIN_SK_BLENDMODE = 6,
    SRCOUT_SK_BLENDMODE = 7,
    DSTOUT_SK_BLENDMODE = 8,
    SRCATOP_SK_BLENDMODE = 9,
    DSTATOP_SK_BLENDMODE = 10,
    XOR_SK_BLENDMODE = 11,
    PLUS_SK_BLENDMODE = 12,
    MODULATE_SK_BLENDMODE = 13,
    SCREEN_SK_BLENDMODE = 14,
    OVERLAY_SK_BLENDMODE = 15,
    DARKEN_SK_BLENDMODE = 16,
    LIGHTEN_SK_BLENDMODE = 17,
    COLORDODGE_SK_BLENDMODE = 18,
    COLORBURN_SK_BLENDMODE = 19,
    HARDLIGHT_SK_BLENDMODE = 20,
    SOFTLIGHT_SK_BLENDMODE = 21,
    DIFFERENCE_SK_BLENDMODE = 22,
    EXCLUSION_SK_BLENDMODE = 23,
    MULTIPLY_SK_BLENDMODE = 24,
    HUE_SK_BLENDMODE = 25,
    SATURATION_SK_BLENDMODE = 26,
    COLOR_SK_BLENDMODE = 27,
    LUMINOSITY_SK_BLENDMODE = 28,
}
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_point3_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_sk_point3_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_point3_t>(),
        12usize,
        concat!("Size of: ", stringify!(sk_point3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_point3_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_point3_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_point3_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point3_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_point3_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point3_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_point3_t>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point3_t),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_ipoint_t {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_sk_ipoint_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_ipoint_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_ipoint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_ipoint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_ipoint_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_ipoint_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_ipoint_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_ipoint_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_ipoint_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_size_t {
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_sk_size_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_size_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_size_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_size_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_size_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_size_t>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_size_t),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_size_t>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_size_t),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_isize_t {
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_sk_isize_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_isize_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_isize_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_isize_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_isize_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_isize_t>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_isize_t),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_isize_t>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_isize_t),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontmetrics_t {
    pub fFlags: u32,
    pub fTop: f32,
    pub fAscent: f32,
    pub fDescent: f32,
    pub fBottom: f32,
    pub fLeading: f32,
    pub fAvgCharWidth: f32,
    pub fMaxCharWidth: f32,
    pub fXMin: f32,
    pub fXMax: f32,
    pub fXHeight: f32,
    pub fCapHeight: f32,
    pub fUnderlineThickness: f32,
    pub fUnderlinePosition: f32,
    pub fStrikeoutThickness: f32,
    pub fStrikeoutPosition: f32,
}
#[test]
fn bindgen_test_layout_sk_fontmetrics_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_fontmetrics_t>(),
        64usize,
        concat!("Size of: ", stringify!(sk_fontmetrics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_fontmetrics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_fontmetrics_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fTop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fAscent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fAscent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fDescent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fDescent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fBottom as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fBottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fLeading as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fLeading)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fAvgCharWidth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fAvgCharWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fMaxCharWidth as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fMaxCharWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fXMin as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fXMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fXMax as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fXMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fXHeight as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fXHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_fontmetrics_t>())).fCapHeight as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fCapHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_fontmetrics_t>())).fUnderlineThickness as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fUnderlineThickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_fontmetrics_t>())).fUnderlinePosition as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fUnderlinePosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_fontmetrics_t>())).fStrikeoutThickness as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fStrikeoutThickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_fontmetrics_t>())).fStrikeoutPosition as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fStrikeoutPosition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_string_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_bitmap_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_pixmap_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorfilter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_imagefilter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_imagefilter_croprect_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_typeface_t {
    _unused: [u8; 0],
}
pub type sk_font_table_tag_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontmgr_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontstyle_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontstyleset_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_codec_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorspace_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_filestream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_asset_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_memorystream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_streamrewindable_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_wstream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_wstream_filestream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_wstream_dynamicmemorystream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_document_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_encoding_t {
    UTF8_ENCODING = 0,
    UTF16_ENCODING = 1,
    UTF32_ENCODING = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_point_mode_t {
    POINTS_SK_POINT_MODE = 0,
    LINES_SK_POINT_MODE = 1,
    POLYGON_SK_POINT_MODE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_text_align_t {
    LEFT_SK_TEXT_ALIGN = 0,
    CENTER_SK_TEXT_ALIGN = 1,
    RIGHT_SK_TEXT_ALIGN = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_text_encoding_t {
    UTF8_SK_TEXT_ENCODING = 0,
    UTF16_SK_TEXT_ENCODING = 1,
    UTF32_SK_TEXT_ENCODING = 2,
    GLYPH_ID_SK_TEXT_ENCODING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_filltype_t {
    WINDING_SK_PATH_FILLTYPE = 0,
    EVENODD_SK_PATH_FILLTYPE = 1,
    INVERSE_WINDING_SK_PATH_FILLTYPE = 2,
    INVERSE_EVENODD_SK_PATH_FILLTYPE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_font_style_slant_t {
    UPRIGHT_SK_FONT_STYLE_SLANT = 0,
    ITALIC_SK_FONT_STYLE_SLANT = 1,
    OBLIQUE_SK_FONT_STYLE_SLANT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_filter_quality_t {
    NONE_SK_FILTER_QUALITY = 0,
    LOW_SK_FILTER_QUALITY = 1,
    MEDIUM_SK_FILTER_QUALITY = 2,
    HIGH_SK_FILTER_QUALITY = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_crop_rect_flags_t {
    HAS_LEFT_SK_CROP_RECT_FLAG = 1,
    HAS_TOP_SK_CROP_RECT_FLAG = 2,
    HAS_WIDTH_SK_CROP_RECT_FLAG = 4,
    HAS_HEIGHT_SK_CROP_RECT_FLAG = 8,
    HAS_ALL_SK_CROP_RECT_FLAG = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_drop_shadow_image_filter_shadow_mode_t {
    DRAW_SHADOW_AND_FOREGROUND_SK_DROP_SHADOW_IMAGE_FILTER_SHADOW_MODE = 0,
    DRAW_SHADOW_ONLY_SK_DROP_SHADOW_IMAGE_FILTER_SHADOW_MODE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_displacement_map_effect_channel_selector_type_t {
    UNKNOWN_SK_DISPLACEMENT_MAP_EFFECT_CHANNEL_SELECTOR_TYPE = 0,
    R_SK_DISPLACEMENT_MAP_EFFECT_CHANNEL_SELECTOR_TYPE = 1,
    G_SK_DISPLACEMENT_MAP_EFFECT_CHANNEL_SELECTOR_TYPE = 2,
    B_SK_DISPLACEMENT_MAP_EFFECT_CHANNEL_SELECTOR_TYPE = 3,
    A_SK_DISPLACEMENT_MAP_EFFECT_CHANNEL_SELECTOR_TYPE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_matrix_convolution_tilemode_t {
    CLAMP_SK_MATRIX_CONVOLUTION_TILEMODE = 0,
    REPEAT_SK_MATRIX_CONVOLUTION_TILEMODE = 1,
    CLAMP_TO_BLACK_SK_MATRIX_CONVOLUTION_TILEMODE = 2,
}
#[repr(u32)]
#[doc = "The logical operations that can be performed when combining two regions."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_region_op_t {
    #[doc = "!< subtract the op region from the first region"]
    DIFFERENCE_SK_REGION_OP = 0,
    #[doc = "!< intersect the two regions"]
    INTERSECT_SK_REGION_OP = 1,
    #[doc = "!< union (inclusive-or) the two regions"]
    UNION_SK_REGION_OP = 2,
    #[doc = "!< exclusive-or the two regions"]
    XOR_SK_REGION_OP = 3,
    #[doc = "!< subtract the first region from the op region"]
    REVERSE_DIFFERENCE_SK_REGION_OP = 4,
    #[doc = "!< replace the dst region with the op region"]
    REPLACE_SK_REGION_OP = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_clipop_t {
    DIFFERENCE_SK_CLIPOP = 0,
    INTERSECT_SK_CLIPOP = 1,
}
#[repr(u32)]
#[doc = "  Enum describing format of encoded data."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_encoded_image_format_t {
    BMP_SK_ENCODED_FORMAT = 0,
    GIF_SK_ENCODED_FORMAT = 1,
    ICO_SK_ENCODED_FORMAT = 2,
    JPEG_SK_ENCODED_FORMAT = 3,
    PNG_SK_ENCODED_FORMAT = 4,
    WBMP_SK_ENCODED_FORMAT = 5,
    WEBP_SK_ENCODED_FORMAT = 6,
    PKM_SK_ENCODED_FORMAT = 7,
    KTX_SK_ENCODED_FORMAT = 8,
    ASTC_SK_ENCODED_FORMAT = 9,
    DNG_SK_ENCODED_FORMAT = 10,
    HEIF_SK_ENCODED_FORMAT = 11,
}
impl sk_encodedorigin_t {
    pub const DEFAULT_SK_ENCODED_ORIGIN: sk_encodedorigin_t =
        sk_encodedorigin_t::TOP_LEFT_SK_ENCODED_ORIGIN;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_encodedorigin_t {
    TOP_LEFT_SK_ENCODED_ORIGIN = 1,
    TOP_RIGHT_SK_ENCODED_ORIGIN = 2,
    BOTTOM_RIGHT_SK_ENCODED_ORIGIN = 3,
    BOTTOM_LEFT_SK_ENCODED_ORIGIN = 4,
    LEFT_TOP_SK_ENCODED_ORIGIN = 5,
    RIGHT_TOP_SK_ENCODED_ORIGIN = 6,
    RIGHT_BOTTOM_SK_ENCODED_ORIGIN = 7,
    LEFT_BOTTOM_SK_ENCODED_ORIGIN = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_codec_result_t {
    SUCCESS_SK_CODEC_RESULT = 0,
    INCOMPLETE_INPUT_SK_CODEC_RESULT = 1,
    ERROR_IN_INPUT_SK_CODEC_RESULT = 2,
    INVALID_CONVERSION_SK_CODEC_RESULT = 3,
    INVALID_SCALE_SK_CODEC_RESULT = 4,
    INVALID_PARAMETERS_SK_CODEC_RESULT = 5,
    INVALID_INPUT_SK_CODEC_RESULT = 6,
    COULD_NOT_REWIND_SK_CODEC_RESULT = 7,
    INTERNAL_ERROR_SK_CODEC_RESULT = 8,
    UNIMPLEMENTED_SK_CODEC_RESULT = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_codec_zero_initialized_t {
    YES_SK_CODEC_ZERO_INITIALIZED = 0,
    NO_SK_CODEC_ZERO_INITIALIZED = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_transfer_function_behavior_t {
    RESPECT_SK_TRANSFER_FUNCTION_BEHAVIOR = 0,
    IGNORE_SK_TRANSFER_FUNCTION_BEHAVIOR = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_codec_options_t {
    pub fZeroInitialized: sk_codec_zero_initialized_t,
    pub fSubset: *mut sk_irect_t,
    pub fFrameIndex: ::std::os::raw::c_int,
    pub fPriorFrame: ::std::os::raw::c_int,
    pub fPremulBehavior: sk_transfer_function_behavior_t,
}
#[test]
fn bindgen_test_layout_sk_codec_options_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_codec_options_t>(),
        32usize,
        concat!("Size of: ", stringify!(sk_codec_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_codec_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_codec_options_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_codec_options_t>())).fZeroInitialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fZeroInitialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_codec_options_t>())).fSubset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fSubset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_codec_options_t>())).fFrameIndex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fFrameIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_codec_options_t>())).fPriorFrame as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fPriorFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_codec_options_t>())).fPremulBehavior as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fPremulBehavior)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_codec_scanline_order_t {
    TOP_DOWN_SK_CODEC_SCANLINE_ORDER = 0,
    BOTTOM_UP_SK_CODEC_SCANLINE_ORDER = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_verb_t {
    MOVE_SK_PATH_VERB = 0,
    LINE_SK_PATH_VERB = 1,
    QUAD_SK_PATH_VERB = 2,
    CONIC_SK_PATH_VERB = 3,
    CUBIC_SK_PATH_VERB = 4,
    CLOSE_SK_PATH_VERB = 5,
    DONE_SK_PATH_VERB = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_iterator_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_rawiterator_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_add_mode_t {
    APPEND_SK_PATH_ADD_MODE = 0,
    EXTEND_SK_PATH_ADD_MODE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_segment_mask_t {
    LINE_SK_PATH_SEGMENT_MASK = 1,
    QUAD_SK_PATH_SEGMENT_MASK = 2,
    CONIC_SK_PATH_SEGMENT_MASK = 4,
    CUBIC_SK_PATH_SEGMENT_MASK = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_effect_1d_style_t {
    TRANSLATE_SK_PATH_EFFECT_1D_STYLE = 0,
    ROTATE_SK_PATH_EFFECT_1D_STYLE = 1,
    MORPH_SK_PATH_EFFECT_1D_STYLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_effect_trim_mode_t {
    NORMAL_SK_PATH_EFFECT_TRIM_MODE = 0,
    INVERTED_SK_PATH_EFFECT_TRIM_MODE = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_effect_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_stroke_cap_t {
    BUTT_SK_STROKE_CAP = 0,
    ROUND_SK_STROKE_CAP = 1,
    SQUARE_SK_STROKE_CAP = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_stroke_join_t {
    MITER_SK_STROKE_JOIN = 0,
    ROUND_SK_STROKE_JOIN = 1,
    BEVEL_SK_STROKE_JOIN = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_shader_tilemode_t {
    CLAMP_SK_SHADER_TILEMODE = 0,
    REPEAT_SK_SHADER_TILEMODE = 1,
    MIRROR_SK_SHADER_TILEMODE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_blurstyle_t {
    #[doc = "!< fuzzy inside and outside"]
    NORMAL_SK_BLUR_STYLE = 0,
    #[doc = "!< solid inside, fuzzy outside"]
    SOLID_SK_BLUR_STYLE = 1,
    #[doc = "!< nothing inside, fuzzy outside"]
    OUTER_SK_BLUR_STYLE = 2,
    #[doc = "!< fuzzy inside, nothing outside"]
    INNER_SK_BLUR_STYLE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_direction_t {
    CW_SK_PATH_DIRECTION = 0,
    CCW_SK_PATH_DIRECTION = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_arc_size_t {
    SMALL_SK_PATH_ARC_SIZE = 0,
    LARGE_SK_PATH_ARC_SIZE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_paint_style_t {
    FILL_SK_PAINT_STYLE = 0,
    STROKE_SK_PAINT_STYLE = 1,
    STROKE_AND_FILL_SK_PAINT_STYLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_paint_hinting_t {
    NO_HINTING_SK_PAINT_HINTING = 0,
    SLIGHT_HINTING_SK_PAINT_HINTING = 1,
    NORMAL_HINTING_SK_PAINT_HINTING = 2,
    FULL_HINTING_SK_PAINT_HINTING = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colortable_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_pixelref_factory_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gr_surfaceorigin_t {
    TOP_LEFT_GR_SURFACE_ORIGIN = 0,
    BOTTOM_LEFT_GR_SURFACE_ORIGIN = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gr_pixelconfig_t {
    UNKNOWN_GR_PIXEL_CONFIG = 0,
    ALPHA_8_GR_PIXEL_CONFIG = 1,
    GRAY_8_GR_PIXEL_CONFIG = 2,
    RGB_565_GR_PIXEL_CONFIG = 3,
    RGBA_4444_GR_PIXEL_CONFIG = 4,
    RGBA_8888_GR_PIXEL_CONFIG = 5,
    RGB_888_GR_PIXEL_CONFIG = 6,
    BGRA_8888_GR_PIXEL_CONFIG = 7,
    SRGBA_8888_GR_PIXEL_CONFIG = 8,
    SBGRA_8888_GR_PIXEL_CONFIG = 9,
    RGBA_1010102_GR_PIXEL_CONFIG = 10,
    RGBA_FLOAT_GR_PIXEL_CONFIG = 11,
    RG_FLOAT_GR_PIXEL_CONFIG = 12,
    ALPHA_HALF_GR_PIXEL_CONFIG = 13,
    RGBA_HALF_GR_PIXEL_CONFIG = 14,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_mask_format_t {
    #[doc = "!< 1bit per pixel mask (e.g. monochrome)"]
    BW_SK_MASK_FORMAT = 0,
    #[doc = "!< 8bits per pixel mask (e.g. antialiasing)"]
    A8_SK_MASK_FORMAT = 1,
    #[doc = "!< 3 8bit per pixl planes: alpha, mul, add"]
    THREE_D_SK_MASK_FORMAT = 2,
    #[doc = "!< SkPMColor"]
    ARGB32_SK_MASK_FORMAT = 3,
    #[doc = "!< 565 alpha for r/g/b"]
    LCD16_SK_MASK_FORMAT = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_mask_t {
    pub fImage: *mut u8,
    pub fBounds: sk_irect_t,
    pub fRowBytes: u32,
    pub fFormat: sk_mask_format_t,
}
#[test]
fn bindgen_test_layout_sk_mask_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_mask_t>(),
        32usize,
        concat!("Size of: ", stringify!(sk_mask_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_mask_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_mask_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_mask_t>())).fImage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_mask_t),
            "::",
            stringify!(fImage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_mask_t>())).fBounds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_mask_t),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_mask_t>())).fRowBytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_mask_t),
            "::",
            stringify!(fRowBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_mask_t>())).fFormat as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_mask_t),
            "::",
            stringify!(fFormat)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gr_context_flushbits_t {
    NONE_GR_CONTEXT_FLUSHBITS = 0,
    DISCARD_GR_CONTEXT_FLUSHBITS = 2,
}
pub type gr_backendobject_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_backendrendertarget_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_backendtexture_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_context_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gr_backend_t {
    METAL_GR_BACKEND = 0,
    OPENGL_GR_BACKEND = 1,
    VULKAN_GR_BACKEND = 2,
}
pub type gr_backendcontext_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_glinterface_t {
    _unused: [u8; 0],
}
pub type gr_gl_func_ptr = ::std::option::Option<unsafe extern "C" fn()>;
pub type gr_gl_get_proc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> gr_gl_func_ptr,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_gl_textureinfo_t {
    pub fTarget: ::std::os::raw::c_uint,
    pub fID: ::std::os::raw::c_uint,
    pub fFormat: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_gr_gl_textureinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<gr_gl_textureinfo_t>(),
        12usize,
        concat!("Size of: ", stringify!(gr_gl_textureinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_gl_textureinfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(gr_gl_textureinfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gr_gl_textureinfo_t>())).fTarget as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_textureinfo_t),
            "::",
            stringify!(fTarget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gr_gl_textureinfo_t>())).fID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_textureinfo_t),
            "::",
            stringify!(fID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gr_gl_textureinfo_t>())).fFormat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_textureinfo_t),
            "::",
            stringify!(fFormat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_gl_framebufferinfo_t {
    pub fFBOID: ::std::os::raw::c_uint,
    pub fFormat: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_gr_gl_framebufferinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<gr_gl_framebufferinfo_t>(),
        8usize,
        concat!("Size of: ", stringify!(gr_gl_framebufferinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_gl_framebufferinfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(gr_gl_framebufferinfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gr_gl_framebufferinfo_t>())).fFBOID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_framebufferinfo_t),
            "::",
            stringify!(fFBOID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gr_gl_framebufferinfo_t>())).fFormat as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_framebufferinfo_t),
            "::",
            stringify!(fFormat)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_pathop_t {
    DIFFERENCE_SK_PATHOP = 0,
    INTERSECT_SK_PATHOP = 1,
    UNION_SK_PATHOP = 2,
    XOR_SK_PATHOP = 3,
    REVERSE_DIFFERENCE_SK_PATHOP = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_opbuilder_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_convexity_t {
    UNKNOWN_SK_PATH_CONVEXITY = 0,
    CONVEX_SK_PATH_CONVEXITY = 1,
    CONCAVE_SK_PATH_CONVEXITY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_lattice_recttype_t {
    DEFAULT_SK_LATTICE_RECT_TYPE = 0,
    TRANSPARENT_SK_LATTICE_RECT_TYPE = 1,
    FIXED_COLOR_SK_LATTICE_RECT_TYPE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_lattice_t {
    pub fXDivs: *const ::std::os::raw::c_int,
    pub fYDivs: *const ::std::os::raw::c_int,
    pub fRectTypes: *const sk_lattice_recttype_t,
    pub fXCount: ::std::os::raw::c_int,
    pub fYCount: ::std::os::raw::c_int,
    pub fBounds: *const sk_irect_t,
    pub fColors: *const sk_color_t,
}
#[test]
fn bindgen_test_layout_sk_lattice_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_lattice_t>(),
        48usize,
        concat!("Size of: ", stringify!(sk_lattice_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_lattice_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_lattice_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_lattice_t>())).fXDivs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fXDivs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_lattice_t>())).fYDivs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fYDivs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_lattice_t>())).fRectTypes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fRectTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_lattice_t>())).fXCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fXCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_lattice_t>())).fYCount as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fYCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_lattice_t>())).fBounds as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_lattice_t>())).fColors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fColors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_pathmeasure_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_pathmeasure_matrixflags_t {
    GET_POSITION_SK_PATHMEASURE_MATRIXFLAGS = 1,
    GET_TANGENT_SK_PATHMEASURE_MATRIXFLAGS = 2,
    GET_POS_AND_TAN_SK_PATHMEASURE_MATRIXFLAGS = 3,
}
pub type sk_bitmap_release_proc = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
pub type sk_data_release_proc = ::std::option::Option<
    unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
pub type sk_image_raster_release_proc = ::std::option::Option<
    unsafe extern "C" fn(addr: *const ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
pub type sk_image_texture_release_proc =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
pub type sk_surface_raster_release_proc = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_image_caching_hint_t {
    ALLOW_SK_IMAGE_CACHING_HINT = 0,
    DISALLOW_SK_IMAGE_CACHING_HINT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_bitmap_allocflags_t {
    ZERO_PIXELS_SK_BITMAP_ALLOC_FLAGS = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_time_datetime_t {
    pub fTimeZoneMinutes: i16,
    pub fYear: u16,
    pub fMonth: u8,
    pub fDayOfWeek: u8,
    pub fDay: u8,
    pub fHour: u8,
    pub fMinute: u8,
    pub fSecond: u8,
}
#[test]
fn bindgen_test_layout_sk_time_datetime_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_time_datetime_t>(),
        10usize,
        concat!("Size of: ", stringify!(sk_time_datetime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_time_datetime_t>(),
        2usize,
        concat!("Alignment of ", stringify!(sk_time_datetime_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_time_datetime_t>())).fTimeZoneMinutes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fTimeZoneMinutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_time_datetime_t>())).fYear as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fYear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_time_datetime_t>())).fMonth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fMonth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_time_datetime_t>())).fDayOfWeek as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fDayOfWeek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_time_datetime_t>())).fDay as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_time_datetime_t>())).fHour as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fHour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_time_datetime_t>())).fMinute as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fMinute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_time_datetime_t>())).fSecond as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fSecond)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_document_pdf_metadata_t {
    pub fTitle: *mut sk_string_t,
    pub fAuthor: *mut sk_string_t,
    pub fSubject: *mut sk_string_t,
    pub fKeywords: *mut sk_string_t,
    pub fCreator: *mut sk_string_t,
    pub fProducer: *mut sk_string_t,
    pub fCreation: *mut sk_time_datetime_t,
    pub fModified: *mut sk_time_datetime_t,
    pub fRasterDPI: f32,
    pub fPDFA: bool,
    pub fEncodingQuality: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sk_document_pdf_metadata_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_document_pdf_metadata_t>(),
        80usize,
        concat!("Size of: ", stringify!(sk_document_pdf_metadata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_document_pdf_metadata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_document_pdf_metadata_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fTitle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fTitle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fAuthor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fAuthor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fSubject as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fSubject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fKeywords as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fKeywords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fCreator as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fCreator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fProducer as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fProducer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fCreation as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fCreation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fModified as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fModified)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fRasterDPI as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fRasterDPI)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fPDFA as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fPDFA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_document_pdf_metadata_t>())).fEncodingQuality as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fEncodingQuality)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_colorspace_named_t {
    SRGB_SK_COLORSPACE_NAMED = 0,
    ADOBE_RGB_SK_COLORSPACE_NAMED = 1,
    SRGB_LINEAR_SK_COLORSPACE_NAMED = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_imageinfo_t {
    pub colorspace: *mut sk_colorspace_t,
    pub width: i32,
    pub height: i32,
    pub colorType: sk_colortype_t,
    pub alphaType: sk_alphatype_t,
}
#[test]
fn bindgen_test_layout_sk_imageinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_imageinfo_t>(),
        24usize,
        concat!("Size of: ", stringify!(sk_imageinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_imageinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_imageinfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_imageinfo_t>())).colorspace as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_imageinfo_t>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_imageinfo_t>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_imageinfo_t>())).colorType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(colorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_imageinfo_t>())).alphaType as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(alphaType)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_codecanimation_disposalmethod_t {
    KEEP_SK_CODEC_ANIMATION_DISPOSAL_METHOD = 1,
    RESTORE_BG_COLOR_SK_CODEC_ANIMATION_DISPOSAL_METHOD = 2,
    RESTORE_PREVIOUS_SK_CODEC_ANIMATION_DISPOSAL_METHOD = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_codec_frameinfo_t {
    pub fRequiredFrame: ::std::os::raw::c_int,
    pub fDuration: ::std::os::raw::c_int,
    pub fFullyReceived: bool,
    pub fAlphaType: sk_alphatype_t,
    pub fDisposalMethod: sk_codecanimation_disposalmethod_t,
}
#[test]
fn bindgen_test_layout_sk_codec_frameinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_codec_frameinfo_t>(),
        20usize,
        concat!("Size of: ", stringify!(sk_codec_frameinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_codec_frameinfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_codec_frameinfo_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_codec_frameinfo_t>())).fRequiredFrame as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fRequiredFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_codec_frameinfo_t>())).fDuration as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_codec_frameinfo_t>())).fFullyReceived as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fFullyReceived)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_codec_frameinfo_t>())).fAlphaType as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fAlphaType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_codec_frameinfo_t>())).fDisposalMethod as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fDisposalMethod)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_xmlstreamwriter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_xmlwriter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_svgcanvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_3dview_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_vertices_vertex_mode_t {
    TRIANGLES_SK_VERTICES_VERTEX_MODE = 0,
    TRIANGLE_STRIP_SK_VERTICES_VERTEX_MODE = 1,
    TRIANGLE_FAN_SK_VERTICES_VERTEX_MODE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_vertices_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_gamma_named_t {
    LINEAR_SK_GAMMA_NAMED = 0,
    SRGB_SK_GAMMA_NAMED = 1,
    TWO_DOT_TWO_CURVE_SK_GAMMA_NAMED = 2,
    NON_STANDARD_SK_GAMMA_NAMED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_colorspace_type_t {
    RGB_SK_COLORSPACE_TYPE = 0,
    CMYK_SK_COLORSPACE_TYPE = 1,
    GRAY_SK_COLORSPACE_TYPE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_colorspace_render_target_gamma_t {
    LINEAR_SK_COLORSPACE_RENDER_TARGET_GAMMA = 0,
    SRGB_SK_COLORSPACE_RENDER_TARGET_GAMMA = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_colorspace_gamut_t {
    SRGB_SK_COLORSPACE_GAMUT = 0,
    ADOBE_RGB_SK_COLORSPACE_GAMUT = 1,
    DCIP3_D65_SK_COLORSPACE_GAMUT = 2,
    REC2020_SK_COLORSPACE_GAMUT = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorspace_transfer_fn_t {
    pub fG: f32,
    pub fA: f32,
    pub fB: f32,
    pub fC: f32,
    pub fD: f32,
    pub fE: f32,
    pub fF: f32,
}
#[test]
fn bindgen_test_layout_sk_colorspace_transfer_fn_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_colorspace_transfer_fn_t>(),
        28usize,
        concat!("Size of: ", stringify!(sk_colorspace_transfer_fn_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_colorspace_transfer_fn_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_colorspace_transfer_fn_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspace_transfer_fn_t>())).fG as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspace_transfer_fn_t>())).fA as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspace_transfer_fn_t>())).fB as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspace_transfer_fn_t>())).fC as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fC)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspace_transfer_fn_t>())).fD as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspace_transfer_fn_t>())).fE as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspace_transfer_fn_t>())).fF as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fF)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorspaceprimaries_t {
    pub fRX: f32,
    pub fRY: f32,
    pub fGX: f32,
    pub fGY: f32,
    pub fBX: f32,
    pub fBY: f32,
    pub fWX: f32,
    pub fWY: f32,
}
#[test]
fn bindgen_test_layout_sk_colorspaceprimaries_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_colorspaceprimaries_t>(),
        32usize,
        concat!("Size of: ", stringify!(sk_colorspaceprimaries_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_colorspaceprimaries_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_colorspaceprimaries_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspaceprimaries_t>())).fRX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspaceprimaries_t),
            "::",
            stringify!(fRX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspaceprimaries_t>())).fRY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspaceprimaries_t),
            "::",
            stringify!(fRY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspaceprimaries_t>())).fGX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspaceprimaries_t),
            "::",
            stringify!(fGX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspaceprimaries_t>())).fGY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspaceprimaries_t),
            "::",
            stringify!(fGY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspaceprimaries_t>())).fBX as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspaceprimaries_t),
            "::",
            stringify!(fBX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspaceprimaries_t>())).fBY as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspaceprimaries_t),
            "::",
            stringify!(fBY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspaceprimaries_t>())).fWX as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspaceprimaries_t),
            "::",
            stringify!(fWX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_colorspaceprimaries_t>())).fWY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspaceprimaries_t),
            "::",
            stringify!(fWY)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_highcontrastconfig_invertstyle_t {
    NO_INVERT_SK_HIGH_CONTRAST_CONFIG_INVERT_STYLE = 0,
    INVERT_BRIGHTNESS_SK_HIGH_CONTRAST_CONFIG_INVERT_STYLE = 1,
    INVERT_LIGHTNESS_SK_HIGH_CONTRAST_CONFIG_INVERT_STYLE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_highcontrastconfig_t {
    pub fGrayscale: bool,
    pub fInvertStyle: sk_highcontrastconfig_invertstyle_t,
    pub fContrast: f32,
}
#[test]
fn bindgen_test_layout_sk_highcontrastconfig_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_highcontrastconfig_t>(),
        12usize,
        concat!("Size of: ", stringify!(sk_highcontrastconfig_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_highcontrastconfig_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_highcontrastconfig_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_highcontrastconfig_t>())).fGrayscale as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_highcontrastconfig_t),
            "::",
            stringify!(fGrayscale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_highcontrastconfig_t>())).fInvertStyle as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_highcontrastconfig_t),
            "::",
            stringify!(fInvertStyle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_highcontrastconfig_t>())).fContrast as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_highcontrastconfig_t),
            "::",
            stringify!(fContrast)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_pngencoder_filterflags_t {
    ZERO_SK_PNGENCODER_FILTER_FLAGS = 0,
    NONE_SK_PNGENCODER_FILTER_FLAGS = 8,
    SUB_SK_PNGENCODER_FILTER_FLAGS = 16,
    UP_SK_PNGENCODER_FILTER_FLAGS = 32,
    AVG_SK_PNGENCODER_FILTER_FLAGS = 64,
    PAETH_SK_PNGENCODER_FILTER_FLAGS = 128,
    ALL_SK_PNGENCODER_FILTER_FLAGS = 248,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_pngencoder_options_t {
    pub fFilterFlags: sk_pngencoder_filterflags_t,
    pub fZLibLevel: ::std::os::raw::c_int,
    pub fUnpremulBehavior: sk_transfer_function_behavior_t,
    pub fComments: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sk_pngencoder_options_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_pngencoder_options_t>(),
        24usize,
        concat!("Size of: ", stringify!(sk_pngencoder_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_pngencoder_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_pngencoder_options_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_pngencoder_options_t>())).fFilterFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fFilterFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_pngencoder_options_t>())).fZLibLevel as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fZLibLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_pngencoder_options_t>())).fUnpremulBehavior as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fUnpremulBehavior)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_pngencoder_options_t>())).fComments as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fComments)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_jpegencoder_downsample_t {
    DOWNSAMPLE_420_SK_JPEGENCODER_DOWNSAMPLE = 0,
    DOWNSAMPLE_422_SK_JPEGENCODER_DOWNSAMPLE = 1,
    DOWNSAMPLE_444_SK_JPEGENCODER_DOWNSAMPLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_jpegencoder_alphaoption_t {
    IGNORE_SK_JPEGENCODER_ALPHA_OPTION = 0,
    BLEND_ON_BLACK_SK_JPEGENCODER_ALPHA_OPTION = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_jpegencoder_options_t {
    pub fQuality: ::std::os::raw::c_int,
    pub fDownsample: sk_jpegencoder_downsample_t,
    pub fAlphaOption: sk_jpegencoder_alphaoption_t,
    pub fBlendBehavior: sk_transfer_function_behavior_t,
}
#[test]
fn bindgen_test_layout_sk_jpegencoder_options_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_jpegencoder_options_t>(),
        16usize,
        concat!("Size of: ", stringify!(sk_jpegencoder_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_jpegencoder_options_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_jpegencoder_options_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_jpegencoder_options_t>())).fQuality as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fQuality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_jpegencoder_options_t>())).fDownsample as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fDownsample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_jpegencoder_options_t>())).fAlphaOption as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fAlphaOption)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_jpegencoder_options_t>())).fBlendBehavior as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fBlendBehavior)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_webpencoder_compression_t {
    LOSSY_SK_WEBPENCODER_COMPTRESSION = 0,
    LOSSLESS_SK_WEBPENCODER_COMPTRESSION = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_webpencoder_options_t {
    pub fCompression: sk_webpencoder_compression_t,
    pub fQuality: f32,
    pub fUnpremulBehavior: sk_transfer_function_behavior_t,
}
#[test]
fn bindgen_test_layout_sk_webpencoder_options_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_webpencoder_options_t>(),
        12usize,
        concat!("Size of: ", stringify!(sk_webpencoder_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_webpencoder_options_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_webpencoder_options_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_webpencoder_options_t>())).fCompression as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_webpencoder_options_t),
            "::",
            stringify!(fCompression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_webpencoder_options_t>())).fQuality as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_webpencoder_options_t),
            "::",
            stringify!(fQuality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_webpencoder_options_t>())).fUnpremulBehavior as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_webpencoder_options_t),
            "::",
            stringify!(fUnpremulBehavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_rrect_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_rrect_type_t {
    EMPTY_SK_RRECT_TYPE = 0,
    RECT_SK_RRECT_TYPE = 1,
    OVAL_SK_RRECT_TYPE = 2,
    SIMPLE_SK_RRECT_TYPE = 3,
    NINE_PATCH_SK_RRECT_TYPE = 4,
    COMPLEX_SK_RRECT_TYPE = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_rrect_corner_t {
    UPPER_LEFT_SK_RRECT_CORNER = 0,
    UPPER_RIGHT_SK_RRECT_CORNER = 1,
    LOWER_RIGHT_SK_RRECT_CORNER = 2,
    LOWER_LEFT_SK_RRECT_CORNER = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_textblob_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_textblob_builder_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_textblob_builder_runbuffer_t {
    pub glyphs: *mut ::std::os::raw::c_void,
    pub pos: *mut ::std::os::raw::c_void,
    pub utf8text: *mut ::std::os::raw::c_void,
    pub clusters: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sk_textblob_builder_runbuffer_t() {
    assert_eq!(
        ::std::mem::size_of::<sk_textblob_builder_runbuffer_t>(),
        32usize,
        concat!("Size of: ", stringify!(sk_textblob_builder_runbuffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_textblob_builder_runbuffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_textblob_builder_runbuffer_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_textblob_builder_runbuffer_t>())).glyphs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_textblob_builder_runbuffer_t),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_textblob_builder_runbuffer_t>())).pos as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_textblob_builder_runbuffer_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_textblob_builder_runbuffer_t>())).utf8text as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_textblob_builder_runbuffer_t),
            "::",
            stringify!(utf8text)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_textblob_builder_runbuffer_t>())).clusters as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_textblob_builder_runbuffer_t),
            "::",
            stringify!(clusters)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_destroy"]
    pub fn sk_canvas_destroy(arg1: *mut sk_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_save"]
    pub fn sk_canvas_save(arg1: *mut sk_canvas_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_save_layer"]
    pub fn sk_canvas_save_layer(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_rect_t,
        arg3: *const sk_paint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_restore"]
    pub fn sk_canvas_restore(arg1: *mut sk_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_translate"]
    pub fn sk_canvas_translate(arg1: *mut sk_canvas_t, dx: f32, dy: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_scale"]
    pub fn sk_canvas_scale(arg1: *mut sk_canvas_t, sx: f32, sy: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_rotate_degrees"]
    pub fn sk_canvas_rotate_degrees(arg1: *mut sk_canvas_t, degrees: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_rotate_radians"]
    pub fn sk_canvas_rotate_radians(arg1: *mut sk_canvas_t, radians: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_skew"]
    pub fn sk_canvas_skew(arg1: *mut sk_canvas_t, sx: f32, sy: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_concat"]
    pub fn sk_canvas_concat(arg1: *mut sk_canvas_t, arg2: *const sk_matrix_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_quick_reject"]
    pub fn sk_canvas_quick_reject(arg1: *mut sk_canvas_t, arg2: *const sk_rect_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_clip_region"]
    pub fn sk_canvas_clip_region(
        canvas: *mut sk_canvas_t,
        region: *const sk_region_t,
        op: sk_clipop_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_paint"]
    pub fn sk_canvas_draw_paint(arg1: *mut sk_canvas_t, arg2: *const sk_paint_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_rect"]
    pub fn sk_canvas_draw_rect(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_rect_t,
        arg3: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_rrect"]
    pub fn sk_canvas_draw_rrect(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_rrect_t,
        arg3: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_region"]
    pub fn sk_canvas_draw_region(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_region_t,
        arg3: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_circle"]
    pub fn sk_canvas_draw_circle(
        arg1: *mut sk_canvas_t,
        cx: f32,
        cy: f32,
        rad: f32,
        arg2: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_oval"]
    pub fn sk_canvas_draw_oval(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_rect_t,
        arg3: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_path"]
    pub fn sk_canvas_draw_path(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_path_t,
        arg3: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_image"]
    pub fn sk_canvas_draw_image(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_image_t,
        x: f32,
        y: f32,
        arg3: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_image_rect"]
    pub fn sk_canvas_draw_image_rect(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_image_t,
        src: *const sk_rect_t,
        dst: *const sk_rect_t,
        arg3: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_picture"]
    pub fn sk_canvas_draw_picture(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_picture_t,
        arg3: *const sk_matrix_t,
        arg4: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_drawable"]
    pub fn sk_canvas_draw_drawable(
        arg1: *mut sk_canvas_t,
        arg2: *mut sk_drawable_t,
        arg3: *const sk_matrix_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_clear"]
    pub fn sk_canvas_clear(arg1: *mut sk_canvas_t, arg2: sk_color_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_discard"]
    pub fn sk_canvas_discard(arg1: *mut sk_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_get_save_count"]
    pub fn sk_canvas_get_save_count(arg1: *mut sk_canvas_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_restore_to_count"]
    pub fn sk_canvas_restore_to_count(arg1: *mut sk_canvas_t, saveCount: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_color"]
    pub fn sk_canvas_draw_color(ccanvas: *mut sk_canvas_t, color: sk_color_t, mode: sk_blendmode_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_points"]
    pub fn sk_canvas_draw_points(
        arg1: *mut sk_canvas_t,
        arg2: sk_point_mode_t,
        arg3: usize,
        arg4: *const sk_point_t,
        arg5: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_point"]
    pub fn sk_canvas_draw_point(
        arg1: *mut sk_canvas_t,
        arg2: f32,
        arg3: f32,
        arg4: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_line"]
    pub fn sk_canvas_draw_line(
        ccanvas: *mut sk_canvas_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        cpaint: *mut sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_text"]
    pub fn sk_canvas_draw_text(
        arg1: *mut sk_canvas_t,
        text: *const ::std::os::raw::c_char,
        byteLength: usize,
        x: f32,
        y: f32,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_pos_text"]
    pub fn sk_canvas_draw_pos_text(
        arg1: *mut sk_canvas_t,
        text: *const ::std::os::raw::c_char,
        byteLength: usize,
        arg2: *const sk_point_t,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_text_on_path"]
    pub fn sk_canvas_draw_text_on_path(
        arg1: *mut sk_canvas_t,
        text: *const ::std::os::raw::c_char,
        byteLength: usize,
        path: *const sk_path_t,
        hOffset: f32,
        vOffset: f32,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_text_blob"]
    pub fn sk_canvas_draw_text_blob(
        arg1: *mut sk_canvas_t,
        text: *mut sk_textblob_t,
        x: f32,
        y: f32,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_bitmap"]
    pub fn sk_canvas_draw_bitmap(
        ccanvas: *mut sk_canvas_t,
        bitmap: *const sk_bitmap_t,
        left: f32,
        top: f32,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_bitmap_rect"]
    pub fn sk_canvas_draw_bitmap_rect(
        ccanvas: *mut sk_canvas_t,
        bitmap: *const sk_bitmap_t,
        src: *const sk_rect_t,
        dst: *const sk_rect_t,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_reset_matrix"]
    pub fn sk_canvas_reset_matrix(ccanvas: *mut sk_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_set_matrix"]
    pub fn sk_canvas_set_matrix(ccanvas: *mut sk_canvas_t, matrix: *const sk_matrix_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_get_total_matrix"]
    pub fn sk_canvas_get_total_matrix(ccanvas: *mut sk_canvas_t, matrix: *mut sk_matrix_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_round_rect"]
    pub fn sk_canvas_draw_round_rect(
        arg1: *mut sk_canvas_t,
        arg2: *const sk_rect_t,
        rx: f32,
        ry: f32,
        arg3: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_clip_rect_with_operation"]
    pub fn sk_canvas_clip_rect_with_operation(
        t: *mut sk_canvas_t,
        crect: *const sk_rect_t,
        op: sk_clipop_t,
        doAA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_clip_path_with_operation"]
    pub fn sk_canvas_clip_path_with_operation(
        t: *mut sk_canvas_t,
        crect: *const sk_path_t,
        op: sk_clipop_t,
        doAA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_clip_rrect_with_operation"]
    pub fn sk_canvas_clip_rrect_with_operation(
        t: *mut sk_canvas_t,
        crect: *const sk_rrect_t,
        op: sk_clipop_t,
        doAA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_get_local_clip_bounds"]
    pub fn sk_canvas_get_local_clip_bounds(t: *mut sk_canvas_t, cbounds: *mut sk_rect_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_get_device_clip_bounds"]
    pub fn sk_canvas_get_device_clip_bounds(t: *mut sk_canvas_t, cbounds: *mut sk_irect_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_flush"]
    pub fn sk_canvas_flush(ccanvas: *mut sk_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_new_from_bitmap"]
    pub fn sk_canvas_new_from_bitmap(bitmap: *const sk_bitmap_t) -> *mut sk_canvas_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_annotation"]
    pub fn sk_canvas_draw_annotation(
        t: *mut sk_canvas_t,
        rect: *const sk_rect_t,
        key: *const ::std::os::raw::c_char,
        value: *mut sk_data_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_url_annotation"]
    pub fn sk_canvas_draw_url_annotation(
        t: *mut sk_canvas_t,
        rect: *const sk_rect_t,
        value: *mut sk_data_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_named_destination_annotation"]
    pub fn sk_canvas_draw_named_destination_annotation(
        t: *mut sk_canvas_t,
        point: *const sk_point_t,
        value: *mut sk_data_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_link_destination_annotation"]
    pub fn sk_canvas_draw_link_destination_annotation(
        t: *mut sk_canvas_t,
        rect: *const sk_rect_t,
        value: *mut sk_data_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_bitmap_lattice"]
    pub fn sk_canvas_draw_bitmap_lattice(
        t: *mut sk_canvas_t,
        bitmap: *const sk_bitmap_t,
        lattice: *const sk_lattice_t,
        dst: *const sk_rect_t,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_image_lattice"]
    pub fn sk_canvas_draw_image_lattice(
        t: *mut sk_canvas_t,
        image: *const sk_image_t,
        lattice: *const sk_lattice_t,
        dst: *const sk_rect_t,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_bitmap_nine"]
    pub fn sk_canvas_draw_bitmap_nine(
        t: *mut sk_canvas_t,
        bitmap: *const sk_bitmap_t,
        center: *const sk_irect_t,
        dst: *const sk_rect_t,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_image_nine"]
    pub fn sk_canvas_draw_image_nine(
        t: *mut sk_canvas_t,
        image: *const sk_image_t,
        center: *const sk_irect_t,
        dst: *const sk_rect_t,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_canvas_draw_vertices"]
    pub fn sk_canvas_draw_vertices(
        ccanvas: *mut sk_canvas_t,
        vertices: *mut sk_vertices_t,
        mode: sk_blendmode_t,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_nodraw_canvas_new"]
    pub fn sk_nodraw_canvas_new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut sk_nodraw_canvas_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_nodraw_canvas_destroy"]
    pub fn sk_nodraw_canvas_destroy(arg1: *mut sk_nodraw_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_nway_canvas_new"]
    pub fn sk_nway_canvas_new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut sk_nway_canvas_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_nway_canvas_destroy"]
    pub fn sk_nway_canvas_destroy(arg1: *mut sk_nway_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_nway_canvas_add_canvas"]
    pub fn sk_nway_canvas_add_canvas(arg1: *mut sk_nway_canvas_t, canvas: *mut sk_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_nway_canvas_remove_canvas"]
    pub fn sk_nway_canvas_remove_canvas(arg1: *mut sk_nway_canvas_t, canvas: *mut sk_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_nway_canvas_remove_all"]
    pub fn sk_nway_canvas_remove_all(arg1: *mut sk_nway_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_overdraw_canvas_new"]
    pub fn sk_overdraw_canvas_new(canvas: *mut sk_canvas_t) -> *mut sk_overdraw_canvas_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_overdraw_canvas_destroy"]
    pub fn sk_overdraw_canvas_destroy(canvas: *mut sk_overdraw_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_unref"]
    pub fn sk_colorspace_unref(cColorSpace: *mut sk_colorspace_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_srgb"]
    pub fn sk_colorspace_new_srgb() -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_srgb_linear"]
    pub fn sk_colorspace_new_srgb_linear() -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_icc"]
    pub fn sk_colorspace_new_icc(
        input: *const ::std::os::raw::c_void,
        len: usize,
    ) -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_rgb_with_gamma"]
    pub fn sk_colorspace_new_rgb_with_gamma(
        gamma: sk_colorspace_render_target_gamma_t,
        toXYZD50: *const sk_matrix44_t,
    ) -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_rgb_with_gamma_and_gamut"]
    pub fn sk_colorspace_new_rgb_with_gamma_and_gamut(
        gamma: sk_colorspace_render_target_gamma_t,
        gamut: sk_colorspace_gamut_t,
    ) -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_rgb_with_coeffs"]
    pub fn sk_colorspace_new_rgb_with_coeffs(
        coeffs: *const sk_colorspace_transfer_fn_t,
        toXYZD50: *const sk_matrix44_t,
    ) -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_rgb_with_coeffs_and_gamut"]
    pub fn sk_colorspace_new_rgb_with_coeffs_and_gamut(
        coeffs: *const sk_colorspace_transfer_fn_t,
        gamut: sk_colorspace_gamut_t,
    ) -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_rgb_with_gamma_named"]
    pub fn sk_colorspace_new_rgb_with_gamma_named(
        gamma: sk_gamma_named_t,
        toXYZD50: *const sk_matrix44_t,
    ) -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_new_rgb_with_gamma_named_and_gamut"]
    pub fn sk_colorspace_new_rgb_with_gamma_named_and_gamut(
        gamma: sk_gamma_named_t,
        gamut: sk_colorspace_gamut_t,
    ) -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_gamma_get_type"]
    pub fn sk_colorspace_gamma_get_type(
        cColorSpace: *const sk_colorspace_t,
    ) -> sk_colorspace_type_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_gamma_get_gamma_named"]
    pub fn sk_colorspace_gamma_get_gamma_named(
        cColorSpace: *const sk_colorspace_t,
    ) -> sk_gamma_named_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_gamma_close_to_srgb"]
    pub fn sk_colorspace_gamma_close_to_srgb(cColorSpace: *const sk_colorspace_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_gamma_is_linear"]
    pub fn sk_colorspace_gamma_is_linear(cColorSpace: *const sk_colorspace_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_is_srgb"]
    pub fn sk_colorspace_is_srgb(cColorSpace: *const sk_colorspace_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_equals"]
    pub fn sk_colorspace_equals(src: *const sk_colorspace_t, dst: *const sk_colorspace_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_to_xyzd50"]
    pub fn sk_colorspace_to_xyzd50(
        cColorSpace: *const sk_colorspace_t,
        toXYZD50: *mut sk_matrix44_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_as_to_xyzd50"]
    pub fn sk_colorspace_as_to_xyzd50(cColorSpace: *const sk_colorspace_t) -> *const sk_matrix44_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_as_from_xyzd50"]
    pub fn sk_colorspace_as_from_xyzd50(
        cColorSpace: *const sk_colorspace_t,
    ) -> *const sk_matrix44_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_is_numerical_transfer_fn"]
    pub fn sk_colorspace_is_numerical_transfer_fn(
        cColorSpace: *const sk_colorspace_t,
        fn_: *mut sk_colorspace_transfer_fn_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspaceprimaries_to_xyzd50"]
    pub fn sk_colorspaceprimaries_to_xyzd50(
        primaries: *const sk_colorspaceprimaries_t,
        toXYZD50: *mut sk_matrix44_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_transfer_fn_invert"]
    pub fn sk_colorspace_transfer_fn_invert(
        transfer: *const sk_colorspace_transfer_fn_t,
        inverted: *mut sk_colorspace_transfer_fn_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_colorspace_transfer_fn_transform"]
    pub fn sk_colorspace_transfer_fn_transform(
        transfer: *const sk_colorspace_transfer_fn_t,
        x: f32,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_new_empty"]
    pub fn sk_data_new_empty() -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_new_with_copy"]
    pub fn sk_data_new_with_copy(
        src: *const ::std::os::raw::c_void,
        length: usize,
    ) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_new_subset"]
    pub fn sk_data_new_subset(
        src: *const sk_data_t,
        offset: usize,
        length: usize,
    ) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_ref"]
    pub fn sk_data_ref(arg1: *const sk_data_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_data_unref"]
    pub fn sk_data_unref(arg1: *const sk_data_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_data_get_size"]
    pub fn sk_data_get_size(arg1: *const sk_data_t) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_get_data"]
    pub fn sk_data_get_data(arg1: *const sk_data_t) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_new_from_file"]
    pub fn sk_data_new_from_file(path: *const ::std::os::raw::c_char) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_new_from_stream"]
    pub fn sk_data_new_from_stream(stream: *mut sk_stream_t, length: usize) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_get_bytes"]
    pub fn sk_data_get_bytes(arg1: *const sk_data_t) -> *const u8;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_new_with_proc"]
    pub fn sk_data_new_with_proc(
        ptr: *const ::std::os::raw::c_void,
        length: usize,
        proc_: sk_data_release_proc,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_data_new_uninitialized"]
    pub fn sk_data_new_uninitialized(size: usize) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_raster_copy"]
    pub fn sk_image_new_raster_copy(
        arg1: *const sk_imageinfo_t,
        pixels: *const ::std::os::raw::c_void,
        rowBytes: usize,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_raster_copy_with_pixmap"]
    pub fn sk_image_new_raster_copy_with_pixmap(pixmap: *const sk_pixmap_t) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_raster_data"]
    pub fn sk_image_new_raster_data(
        cinfo: *const sk_imageinfo_t,
        pixels: *mut sk_data_t,
        rowBytes: usize,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_raster"]
    pub fn sk_image_new_raster(
        pixmap: *const sk_pixmap_t,
        releaseProc: sk_image_raster_release_proc,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_from_bitmap"]
    pub fn sk_image_new_from_bitmap(cbitmap: *const sk_bitmap_t) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_from_encoded"]
    pub fn sk_image_new_from_encoded(
        encoded: *mut sk_data_t,
        subset: *const sk_irect_t,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_from_texture"]
    pub fn sk_image_new_from_texture(
        context: *mut gr_context_t,
        texture: *const gr_backendtexture_t,
        origin: gr_surfaceorigin_t,
        colorType: sk_colortype_t,
        alpha: sk_alphatype_t,
        colorSpace: *mut sk_colorspace_t,
        releaseProc: sk_image_texture_release_proc,
        releaseContext: *mut ::std::os::raw::c_void,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_from_adopted_texture"]
    pub fn sk_image_new_from_adopted_texture(
        context: *mut gr_context_t,
        texture: *const gr_backendtexture_t,
        origin: gr_surfaceorigin_t,
        colorType: sk_colortype_t,
        alpha: sk_alphatype_t,
        colorSpace: *mut sk_colorspace_t,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_new_from_picture"]
    pub fn sk_image_new_from_picture(
        picture: *mut sk_picture_t,
        dimensions: *const sk_isize_t,
        matrix: *const sk_matrix_t,
        paint: *const sk_paint_t,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_make_subset"]
    pub fn sk_image_make_subset(
        cimage: *const sk_image_t,
        subset: *const sk_irect_t,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_make_non_texture_image"]
    pub fn sk_image_make_non_texture_image(cimage: *const sk_image_t) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_make_with_filter"]
    pub fn sk_image_make_with_filter(
        cimage: *const sk_image_t,
        filter: *const sk_imagefilter_t,
        subset: *const sk_irect_t,
        clipBounds: *const sk_irect_t,
        outSubset: *mut sk_irect_t,
        outOffset: *mut sk_ipoint_t,
    ) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_ref"]
    pub fn sk_image_ref(arg1: *const sk_image_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_image_unref"]
    pub fn sk_image_unref(arg1: *const sk_image_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_image_get_width"]
    pub fn sk_image_get_width(arg1: *const sk_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_get_height"]
    pub fn sk_image_get_height(arg1: *const sk_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_get_unique_id"]
    pub fn sk_image_get_unique_id(arg1: *const sk_image_t) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_get_alpha_type"]
    pub fn sk_image_get_alpha_type(arg1: *const sk_image_t) -> sk_alphatype_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_get_color_type"]
    pub fn sk_image_get_color_type(arg1: *const sk_image_t) -> sk_colortype_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_get_colorspace"]
    pub fn sk_image_get_colorspace(arg1: *const sk_image_t) -> *mut sk_colorspace_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_is_alpha_only"]
    pub fn sk_image_is_alpha_only(arg1: *const sk_image_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_make_shader"]
    pub fn sk_image_make_shader(
        arg1: *const sk_image_t,
        tileX: sk_shader_tilemode_t,
        tileY: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_peek_pixels"]
    pub fn sk_image_peek_pixels(image: *const sk_image_t, pixmap: *mut sk_pixmap_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_is_texture_backed"]
    pub fn sk_image_is_texture_backed(image: *const sk_image_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_is_lazy_generated"]
    pub fn sk_image_is_lazy_generated(image: *const sk_image_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_read_pixels"]
    pub fn sk_image_read_pixels(
        image: *const sk_image_t,
        dstInfo: *const sk_imageinfo_t,
        dstPixels: *mut ::std::os::raw::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: sk_image_caching_hint_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_read_pixels_into_pixmap"]
    pub fn sk_image_read_pixels_into_pixmap(
        image: *const sk_image_t,
        dst: *const sk_pixmap_t,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: sk_image_caching_hint_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_scale_pixels"]
    pub fn sk_image_scale_pixels(
        image: *const sk_image_t,
        dst: *const sk_pixmap_t,
        quality: sk_filter_quality_t,
        cachingHint: sk_image_caching_hint_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_ref_encoded"]
    pub fn sk_image_ref_encoded(arg1: *const sk_image_t) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_encode"]
    pub fn sk_image_encode(arg1: *const sk_image_t) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_image_encode_specific"]
    pub fn sk_image_encode_specific(
        cimage: *const sk_image_t,
        encoder: sk_encoded_image_format_t,
        quality: ::std::os::raw::c_int,
    ) -> *mut sk_data_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_maskfilter_ref"]
    pub fn sk_maskfilter_ref(arg1: *mut sk_maskfilter_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_maskfilter_unref"]
    pub fn sk_maskfilter_unref(arg1: *mut sk_maskfilter_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_maskfilter_new_blur"]
    pub fn sk_maskfilter_new_blur(arg1: sk_blurstyle_t, sigma: f32) -> *mut sk_maskfilter_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_maskfilter_new_blur_with_flags"]
    pub fn sk_maskfilter_new_blur_with_flags(
        arg1: sk_blurstyle_t,
        sigma: f32,
        occluder: *const sk_rect_t,
        respectCTM: bool,
    ) -> *mut sk_maskfilter_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_maskfilter_new_table"]
    pub fn sk_maskfilter_new_table(table: *const u8) -> *mut sk_maskfilter_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_maskfilter_new_gamma"]
    pub fn sk_maskfilter_new_gamma(gamma: f32) -> *mut sk_maskfilter_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_maskfilter_new_clip"]
    pub fn sk_maskfilter_new_clip(min: u8, max: u8) -> *mut sk_maskfilter_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_try_invert"]
    pub fn sk_matrix_try_invert(matrix: *mut sk_matrix_t, result: *mut sk_matrix_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_concat"]
    pub fn sk_matrix_concat(
        result: *mut sk_matrix_t,
        first: *mut sk_matrix_t,
        second: *mut sk_matrix_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_pre_concat"]
    pub fn sk_matrix_pre_concat(result: *mut sk_matrix_t, matrix: *mut sk_matrix_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_post_concat"]
    pub fn sk_matrix_post_concat(result: *mut sk_matrix_t, matrix: *mut sk_matrix_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_map_rect"]
    pub fn sk_matrix_map_rect(
        matrix: *mut sk_matrix_t,
        dest: *mut sk_rect_t,
        source: *mut sk_rect_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_map_points"]
    pub fn sk_matrix_map_points(
        matrix: *mut sk_matrix_t,
        dst: *mut sk_point_t,
        src: *mut sk_point_t,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_map_vectors"]
    pub fn sk_matrix_map_vectors(
        matrix: *mut sk_matrix_t,
        dst: *mut sk_point_t,
        src: *mut sk_point_t,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_map_xy"]
    pub fn sk_matrix_map_xy(matrix: *mut sk_matrix_t, x: f32, y: f32, result: *mut sk_point_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_map_vector"]
    pub fn sk_matrix_map_vector(matrix: *mut sk_matrix_t, x: f32, y: f32, result: *mut sk_point_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix_map_radius"]
    pub fn sk_matrix_map_radius(matrix: *mut sk_matrix_t, radius: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_new"]
    pub fn sk_3dview_new() -> *mut sk_3dview_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_destroy"]
    pub fn sk_3dview_destroy(cview: *mut sk_3dview_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_save"]
    pub fn sk_3dview_save(cview: *mut sk_3dview_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_restore"]
    pub fn sk_3dview_restore(cview: *mut sk_3dview_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_translate"]
    pub fn sk_3dview_translate(cview: *mut sk_3dview_t, x: f32, y: f32, z: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_rotate_x_degrees"]
    pub fn sk_3dview_rotate_x_degrees(cview: *mut sk_3dview_t, degrees: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_rotate_y_degrees"]
    pub fn sk_3dview_rotate_y_degrees(cview: *mut sk_3dview_t, degrees: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_rotate_z_degrees"]
    pub fn sk_3dview_rotate_z_degrees(cview: *mut sk_3dview_t, degrees: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_rotate_x_radians"]
    pub fn sk_3dview_rotate_x_radians(cview: *mut sk_3dview_t, radians: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_rotate_y_radians"]
    pub fn sk_3dview_rotate_y_radians(cview: *mut sk_3dview_t, radians: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_rotate_z_radians"]
    pub fn sk_3dview_rotate_z_radians(cview: *mut sk_3dview_t, radians: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_get_matrix"]
    pub fn sk_3dview_get_matrix(cview: *mut sk_3dview_t, cmatrix: *mut sk_matrix_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_apply_to_canvas"]
    pub fn sk_3dview_apply_to_canvas(cview: *mut sk_3dview_t, ccanvas: *mut sk_canvas_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_3dview_dot_with_normal"]
    pub fn sk_3dview_dot_with_normal(cview: *mut sk_3dview_t, dx: f32, dy: f32, dz: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_destroy"]
    pub fn sk_matrix44_destroy(matrix: *mut sk_matrix44_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_new"]
    pub fn sk_matrix44_new() -> *mut sk_matrix44_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_new_identity"]
    pub fn sk_matrix44_new_identity() -> *mut sk_matrix44_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_new_copy"]
    pub fn sk_matrix44_new_copy(src: *const sk_matrix44_t) -> *mut sk_matrix44_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_new_concat"]
    pub fn sk_matrix44_new_concat(
        a: *const sk_matrix44_t,
        b: *const sk_matrix44_t,
    ) -> *mut sk_matrix44_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_new_matrix"]
    pub fn sk_matrix44_new_matrix(src: *const sk_matrix_t) -> *mut sk_matrix44_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_equals"]
    pub fn sk_matrix44_equals(matrix: *mut sk_matrix44_t, other: *const sk_matrix44_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_to_matrix"]
    pub fn sk_matrix44_to_matrix(matrix: *mut sk_matrix44_t, dst: *mut sk_matrix_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_get_type"]
    pub fn sk_matrix44_get_type(matrix: *mut sk_matrix44_t) -> sk_matrix44_type_mask_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_identity"]
    pub fn sk_matrix44_set_identity(matrix: *mut sk_matrix44_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_get"]
    pub fn sk_matrix44_get(
        matrix: *mut sk_matrix44_t,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set"]
    pub fn sk_matrix44_set(
        matrix: *mut sk_matrix44_t,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        value: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_as_col_major"]
    pub fn sk_matrix44_as_col_major(matrix: *mut sk_matrix44_t, dst: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_as_row_major"]
    pub fn sk_matrix44_as_row_major(matrix: *mut sk_matrix44_t, dst: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_col_major"]
    pub fn sk_matrix44_set_col_major(matrix: *mut sk_matrix44_t, dst: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_row_major"]
    pub fn sk_matrix44_set_row_major(matrix: *mut sk_matrix44_t, dst: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_translate"]
    pub fn sk_matrix44_set_translate(matrix: *mut sk_matrix44_t, dx: f32, dy: f32, dz: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_pre_translate"]
    pub fn sk_matrix44_pre_translate(matrix: *mut sk_matrix44_t, dx: f32, dy: f32, dz: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_post_translate"]
    pub fn sk_matrix44_post_translate(matrix: *mut sk_matrix44_t, dx: f32, dy: f32, dz: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_scale"]
    pub fn sk_matrix44_set_scale(matrix: *mut sk_matrix44_t, sx: f32, sy: f32, sz: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_pre_scale"]
    pub fn sk_matrix44_pre_scale(matrix: *mut sk_matrix44_t, sx: f32, sy: f32, sz: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_post_scale"]
    pub fn sk_matrix44_post_scale(matrix: *mut sk_matrix44_t, sx: f32, sy: f32, sz: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_rotate_about_degrees"]
    pub fn sk_matrix44_set_rotate_about_degrees(
        matrix: *mut sk_matrix44_t,
        x: f32,
        y: f32,
        z: f32,
        degrees: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_rotate_about_radians"]
    pub fn sk_matrix44_set_rotate_about_radians(
        matrix: *mut sk_matrix44_t,
        x: f32,
        y: f32,
        z: f32,
        radians: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_rotate_about_radians_unit"]
    pub fn sk_matrix44_set_rotate_about_radians_unit(
        matrix: *mut sk_matrix44_t,
        x: f32,
        y: f32,
        z: f32,
        radians: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_set_concat"]
    pub fn sk_matrix44_set_concat(
        matrix: *mut sk_matrix44_t,
        a: *const sk_matrix44_t,
        b: *const sk_matrix44_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_pre_concat"]
    pub fn sk_matrix44_pre_concat(matrix: *mut sk_matrix44_t, m: *const sk_matrix44_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_post_concat"]
    pub fn sk_matrix44_post_concat(matrix: *mut sk_matrix44_t, m: *const sk_matrix44_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_invert"]
    pub fn sk_matrix44_invert(matrix: *mut sk_matrix44_t, inverse: *mut sk_matrix44_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_transpose"]
    pub fn sk_matrix44_transpose(matrix: *mut sk_matrix44_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_map_scalars"]
    pub fn sk_matrix44_map_scalars(matrix: *mut sk_matrix44_t, src: *const f32, dst: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_map2"]
    pub fn sk_matrix44_map2(
        matrix: *mut sk_matrix44_t,
        src2: *const f32,
        count: ::std::os::raw::c_int,
        dst4: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_preserves_2d_axis_alignment"]
    pub fn sk_matrix44_preserves_2d_axis_alignment(
        matrix: *mut sk_matrix44_t,
        epsilon: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_matrix44_determinant"]
    pub fn sk_matrix44_determinant(matrix: *mut sk_matrix44_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_new"]
    pub fn sk_paint_new() -> *mut sk_paint_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_clone"]
    pub fn sk_paint_clone(arg1: *mut sk_paint_t) -> *mut sk_paint_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_delete"]
    pub fn sk_paint_delete(arg1: *mut sk_paint_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_antialias"]
    pub fn sk_paint_is_antialias(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_antialias"]
    pub fn sk_paint_set_antialias(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_color"]
    pub fn sk_paint_get_color(arg1: *const sk_paint_t) -> sk_color_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_color"]
    pub fn sk_paint_set_color(arg1: *mut sk_paint_t, arg2: sk_color_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_style"]
    pub fn sk_paint_get_style(arg1: *const sk_paint_t) -> sk_paint_style_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_style"]
    pub fn sk_paint_set_style(arg1: *mut sk_paint_t, arg2: sk_paint_style_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_stroke_width"]
    pub fn sk_paint_get_stroke_width(arg1: *const sk_paint_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_stroke_width"]
    pub fn sk_paint_set_stroke_width(arg1: *mut sk_paint_t, width: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_stroke_miter"]
    pub fn sk_paint_get_stroke_miter(arg1: *const sk_paint_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_stroke_miter"]
    pub fn sk_paint_set_stroke_miter(arg1: *mut sk_paint_t, miter: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_stroke_cap"]
    pub fn sk_paint_get_stroke_cap(arg1: *const sk_paint_t) -> sk_stroke_cap_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_stroke_cap"]
    pub fn sk_paint_set_stroke_cap(arg1: *mut sk_paint_t, arg2: sk_stroke_cap_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_stroke_join"]
    pub fn sk_paint_get_stroke_join(arg1: *const sk_paint_t) -> sk_stroke_join_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_stroke_join"]
    pub fn sk_paint_set_stroke_join(arg1: *mut sk_paint_t, arg2: sk_stroke_join_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_shader"]
    pub fn sk_paint_set_shader(arg1: *mut sk_paint_t, arg2: *mut sk_shader_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_maskfilter"]
    pub fn sk_paint_set_maskfilter(arg1: *mut sk_paint_t, arg2: *mut sk_maskfilter_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_blendmode"]
    pub fn sk_paint_set_blendmode(arg1: *mut sk_paint_t, arg2: sk_blendmode_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_dither"]
    pub fn sk_paint_is_dither(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_dither"]
    pub fn sk_paint_set_dither(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_verticaltext"]
    pub fn sk_paint_is_verticaltext(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_verticaltext"]
    pub fn sk_paint_set_verticaltext(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_shader"]
    pub fn sk_paint_get_shader(arg1: *mut sk_paint_t) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_maskfilter"]
    pub fn sk_paint_get_maskfilter(arg1: *mut sk_paint_t) -> *mut sk_maskfilter_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_colorfilter"]
    pub fn sk_paint_set_colorfilter(arg1: *mut sk_paint_t, arg2: *mut sk_colorfilter_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_colorfilter"]
    pub fn sk_paint_get_colorfilter(arg1: *mut sk_paint_t) -> *mut sk_colorfilter_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_imagefilter"]
    pub fn sk_paint_set_imagefilter(arg1: *mut sk_paint_t, arg2: *mut sk_imagefilter_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_imagefilter"]
    pub fn sk_paint_get_imagefilter(arg1: *mut sk_paint_t) -> *mut sk_imagefilter_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_blendmode"]
    pub fn sk_paint_get_blendmode(arg1: *mut sk_paint_t) -> sk_blendmode_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_filter_quality"]
    pub fn sk_paint_set_filter_quality(arg1: *mut sk_paint_t, arg2: sk_filter_quality_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_filter_quality"]
    pub fn sk_paint_get_filter_quality(arg1: *mut sk_paint_t) -> sk_filter_quality_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_typeface"]
    pub fn sk_paint_get_typeface(arg1: *mut sk_paint_t) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_typeface"]
    pub fn sk_paint_set_typeface(arg1: *mut sk_paint_t, arg2: *mut sk_typeface_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_textsize"]
    pub fn sk_paint_get_textsize(arg1: *mut sk_paint_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_textsize"]
    pub fn sk_paint_set_textsize(arg1: *mut sk_paint_t, arg2: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_text_align"]
    pub fn sk_paint_get_text_align(arg1: *const sk_paint_t) -> sk_text_align_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_text_align"]
    pub fn sk_paint_set_text_align(arg1: *mut sk_paint_t, arg2: sk_text_align_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_text_encoding"]
    pub fn sk_paint_get_text_encoding(arg1: *const sk_paint_t) -> sk_text_encoding_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_text_encoding"]
    pub fn sk_paint_set_text_encoding(arg1: *mut sk_paint_t, arg2: sk_text_encoding_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_text_scale_x"]
    pub fn sk_paint_get_text_scale_x(cpaint: *const sk_paint_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_text_scale_x"]
    pub fn sk_paint_set_text_scale_x(cpaint: *mut sk_paint_t, scale: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_text_skew_x"]
    pub fn sk_paint_get_text_skew_x(cpaint: *const sk_paint_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_text_skew_x"]
    pub fn sk_paint_set_text_skew_x(cpaint: *mut sk_paint_t, skew: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_break_text"]
    pub fn sk_paint_break_text(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        length: usize,
        maxWidth: f32,
        measuredWidth: *mut f32,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_measure_text"]
    pub fn sk_paint_measure_text(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        length: usize,
        cbounds: *mut sk_rect_t,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_text_path"]
    pub fn sk_paint_get_text_path(
        cpaint: *mut sk_paint_t,
        text: *const ::std::os::raw::c_void,
        length: usize,
        x: f32,
        y: f32,
    ) -> *mut sk_path_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_pos_text_path"]
    pub fn sk_paint_get_pos_text_path(
        cpaint: *mut sk_paint_t,
        text: *const ::std::os::raw::c_void,
        length: usize,
        pos: *const sk_point_t,
    ) -> *mut sk_path_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_fontmetrics"]
    pub fn sk_paint_get_fontmetrics(
        cpaint: *mut sk_paint_t,
        cfontmetrics: *mut sk_fontmetrics_t,
        scale: f32,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_path_effect"]
    pub fn sk_paint_get_path_effect(cpaint: *mut sk_paint_t) -> *mut sk_path_effect_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_path_effect"]
    pub fn sk_paint_set_path_effect(cpaint: *mut sk_paint_t, effect: *mut sk_path_effect_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_linear_text"]
    pub fn sk_paint_is_linear_text(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_linear_text"]
    pub fn sk_paint_set_linear_text(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_subpixel_text"]
    pub fn sk_paint_is_subpixel_text(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_subpixel_text"]
    pub fn sk_paint_set_subpixel_text(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_lcd_render_text"]
    pub fn sk_paint_is_lcd_render_text(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_lcd_render_text"]
    pub fn sk_paint_set_lcd_render_text(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_embedded_bitmap_text"]
    pub fn sk_paint_is_embedded_bitmap_text(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_embedded_bitmap_text"]
    pub fn sk_paint_set_embedded_bitmap_text(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_hinting"]
    pub fn sk_paint_get_hinting(arg1: *const sk_paint_t) -> sk_paint_hinting_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_hinting"]
    pub fn sk_paint_set_hinting(arg1: *mut sk_paint_t, arg2: sk_paint_hinting_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_autohinted"]
    pub fn sk_paint_is_autohinted(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_autohinted"]
    pub fn sk_paint_set_autohinted(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_fake_bold_text"]
    pub fn sk_paint_is_fake_bold_text(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_fake_bold_text"]
    pub fn sk_paint_set_fake_bold_text(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_is_dev_kern_text"]
    pub fn sk_paint_is_dev_kern_text(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_set_dev_kern_text"]
    pub fn sk_paint_set_dev_kern_text(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_fill_path"]
    pub fn sk_paint_get_fill_path(
        arg1: *const sk_paint_t,
        src: *const sk_path_t,
        dst: *mut sk_path_t,
        cullRect: *const sk_rect_t,
        resScale: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_text_to_glyphs"]
    pub fn sk_paint_text_to_glyphs(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        glyphs: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_contains_text"]
    pub fn sk_paint_contains_text(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_count_text"]
    pub fn sk_paint_count_text(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_text_widths"]
    pub fn sk_paint_get_text_widths(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        widths: *mut f32,
        bounds: *mut sk_rect_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_text_intercepts"]
    pub fn sk_paint_get_text_intercepts(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        x: f32,
        y: f32,
        bounds: *const f32,
        intervals: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_pos_text_intercepts"]
    pub fn sk_paint_get_pos_text_intercepts(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        pos: *mut sk_point_t,
        bounds: *const f32,
        intervals: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_pos_text_h_intercepts"]
    pub fn sk_paint_get_pos_text_h_intercepts(
        cpaint: *const sk_paint_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        xpos: *mut f32,
        y: f32,
        bounds: *const f32,
        intervals: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_paint_get_pos_text_blob_intercepts"]
    pub fn sk_paint_get_pos_text_blob_intercepts(
        cpaint: *const sk_paint_t,
        blob: *mut sk_textblob_t,
        bounds: *const f32,
        intervals: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_new"]
    pub fn sk_path_new() -> *mut sk_path_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_delete"]
    pub fn sk_path_delete(arg1: *mut sk_path_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_move_to"]
    pub fn sk_path_move_to(arg1: *mut sk_path_t, x: f32, y: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_line_to"]
    pub fn sk_path_line_to(arg1: *mut sk_path_t, x: f32, y: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_quad_to"]
    pub fn sk_path_quad_to(arg1: *mut sk_path_t, x0: f32, y0: f32, x1: f32, y1: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_conic_to"]
    pub fn sk_path_conic_to(arg1: *mut sk_path_t, x0: f32, y0: f32, x1: f32, y1: f32, w: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_cubic_to"]
    pub fn sk_path_cubic_to(
        arg1: *mut sk_path_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_arc_to"]
    pub fn sk_path_arc_to(
        arg1: *mut sk_path_t,
        rx: f32,
        ry: f32,
        xAxisRotate: f32,
        largeArc: sk_path_arc_size_t,
        sweep: sk_path_direction_t,
        x: f32,
        y: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rarc_to"]
    pub fn sk_path_rarc_to(
        arg1: *mut sk_path_t,
        rx: f32,
        ry: f32,
        xAxisRotate: f32,
        largeArc: sk_path_arc_size_t,
        sweep: sk_path_direction_t,
        x: f32,
        y: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_arc_to_with_oval"]
    pub fn sk_path_arc_to_with_oval(
        arg1: *mut sk_path_t,
        oval: *const sk_rect_t,
        startAngle: f32,
        sweepAngle: f32,
        forceMoveTo: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_arc_to_with_points"]
    pub fn sk_path_arc_to_with_points(
        arg1: *mut sk_path_t,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
        radius: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_close"]
    pub fn sk_path_close(arg1: *mut sk_path_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_rect"]
    pub fn sk_path_add_rect(
        arg1: *mut sk_path_t,
        arg2: *const sk_rect_t,
        arg3: sk_path_direction_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_rrect"]
    pub fn sk_path_add_rrect(
        arg1: *mut sk_path_t,
        arg2: *const sk_rrect_t,
        arg3: sk_path_direction_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_rrect_start"]
    pub fn sk_path_add_rrect_start(
        arg1: *mut sk_path_t,
        arg2: *const sk_rrect_t,
        arg3: sk_path_direction_t,
        arg4: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_rounded_rect"]
    pub fn sk_path_add_rounded_rect(
        arg1: *mut sk_path_t,
        arg2: *const sk_rect_t,
        arg3: f32,
        arg4: f32,
        arg5: sk_path_direction_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_oval"]
    pub fn sk_path_add_oval(
        arg1: *mut sk_path_t,
        arg2: *const sk_rect_t,
        arg3: sk_path_direction_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_circle"]
    pub fn sk_path_add_circle(
        arg1: *mut sk_path_t,
        x: f32,
        y: f32,
        radius: f32,
        dir: sk_path_direction_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_get_bounds"]
    pub fn sk_path_get_bounds(arg1: *const sk_path_t, arg2: *mut sk_rect_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_compute_tight_bounds"]
    pub fn sk_path_compute_tight_bounds(arg1: *const sk_path_t, arg2: *mut sk_rect_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rmove_to"]
    pub fn sk_path_rmove_to(arg1: *mut sk_path_t, dx: f32, dy: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rline_to"]
    pub fn sk_path_rline_to(arg1: *mut sk_path_t, dx: f32, yd: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rquad_to"]
    pub fn sk_path_rquad_to(arg1: *mut sk_path_t, dx0: f32, dy0: f32, dx1: f32, dy1: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rconic_to"]
    pub fn sk_path_rconic_to(arg1: *mut sk_path_t, dx0: f32, dy0: f32, dx1: f32, dy1: f32, w: f32);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rcubic_to"]
    pub fn sk_path_rcubic_to(
        arg1: *mut sk_path_t,
        dx0: f32,
        dy0: f32,
        dx1: f32,
        dy1: f32,
        dx2: f32,
        dy2: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_rect_start"]
    pub fn sk_path_add_rect_start(
        cpath: *mut sk_path_t,
        crect: *const sk_rect_t,
        cdir: sk_path_direction_t,
        startIndex: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_arc"]
    pub fn sk_path_add_arc(
        cpath: *mut sk_path_t,
        crect: *const sk_rect_t,
        startAngle: f32,
        sweepAngle: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_get_filltype"]
    pub fn sk_path_get_filltype(arg1: *mut sk_path_t) -> sk_path_filltype_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_set_filltype"]
    pub fn sk_path_set_filltype(arg1: *mut sk_path_t, arg2: sk_path_filltype_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_transform"]
    pub fn sk_path_transform(cpath: *mut sk_path_t, cmatrix: *const sk_matrix_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_clone"]
    pub fn sk_path_clone(cpath: *const sk_path_t) -> *mut sk_path_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_path_offset"]
    pub fn sk_path_add_path_offset(
        cpath: *mut sk_path_t,
        other: *mut sk_path_t,
        dx: f32,
        dy: f32,
        add_mode: sk_path_add_mode_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_path_matrix"]
    pub fn sk_path_add_path_matrix(
        cpath: *mut sk_path_t,
        other: *mut sk_path_t,
        matrix: *mut sk_matrix_t,
        add_mode: sk_path_add_mode_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_path"]
    pub fn sk_path_add_path(
        cpath: *mut sk_path_t,
        other: *mut sk_path_t,
        add_mode: sk_path_add_mode_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_path_reverse"]
    pub fn sk_path_add_path_reverse(cpath: *mut sk_path_t, other: *mut sk_path_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_reset"]
    pub fn sk_path_reset(cpath: *mut sk_path_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rewind"]
    pub fn sk_path_rewind(cpath: *mut sk_path_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_count_points"]
    pub fn sk_path_count_points(cpath: *const sk_path_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_count_verbs"]
    pub fn sk_path_count_verbs(cpath: *const sk_path_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_get_point"]
    pub fn sk_path_get_point(
        cpath: *const sk_path_t,
        index: ::std::os::raw::c_int,
        point: *mut sk_point_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_get_points"]
    pub fn sk_path_get_points(
        cpath: *const sk_path_t,
        points: *mut sk_point_t,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_contains"]
    pub fn sk_path_contains(cpath: *const sk_path_t, x: f32, y: f32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_get_convexity"]
    pub fn sk_path_get_convexity(cpath: *const sk_path_t) -> sk_path_convexity_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_set_convexity"]
    pub fn sk_path_set_convexity(cpath: *mut sk_path_t, convexity: sk_path_convexity_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_parse_svg_string"]
    pub fn sk_path_parse_svg_string(
        cpath: *mut sk_path_t,
        str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_to_svg_string"]
    pub fn sk_path_to_svg_string(cpath: *const sk_path_t, str: *mut sk_string_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_get_last_point"]
    pub fn sk_path_get_last_point(cpath: *const sk_path_t, point: *mut sk_point_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_convert_conic_to_quads"]
    pub fn sk_path_convert_conic_to_quads(
        p0: *const sk_point_t,
        p1: *const sk_point_t,
        p2: *const sk_point_t,
        w: f32,
        pts: *mut sk_point_t,
        pow2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_add_poly"]
    pub fn sk_path_add_poly(
        cpath: *mut sk_path_t,
        points: *const sk_point_t,
        count: ::std::os::raw::c_int,
        close: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_path_get_segment_masks"]
    pub fn sk_path_get_segment_masks(cpath: *mut sk_path_t) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_is_oval"]
    pub fn sk_path_is_oval(cpath: *mut sk_path_t, bounds: *mut sk_rect_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_is_rrect"]
    pub fn sk_path_is_rrect(cpath: *mut sk_path_t, bounds: *mut sk_rrect_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_is_line"]
    pub fn sk_path_is_line(cpath: *mut sk_path_t, line: *mut sk_point_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_is_rect"]
    pub fn sk_path_is_rect(
        cpath: *mut sk_path_t,
        rect: *mut sk_rect_t,
        isClosed: *mut bool,
        direction: *mut sk_path_direction_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_create_iter"]
    pub fn sk_path_create_iter(
        cpath: *mut sk_path_t,
        forceClose: ::std::os::raw::c_int,
    ) -> *mut sk_path_iterator_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_iter_next"]
    pub fn sk_path_iter_next(
        iterator: *mut sk_path_iterator_t,
        points: *mut sk_point_t,
        doConsumeDegenerates: ::std::os::raw::c_int,
        exact: ::std::os::raw::c_int,
    ) -> sk_path_verb_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_iter_conic_weight"]
    pub fn sk_path_iter_conic_weight(iterator: *mut sk_path_iterator_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_iter_is_close_line"]
    pub fn sk_path_iter_is_close_line(iterator: *mut sk_path_iterator_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_iter_is_closed_contour"]
    pub fn sk_path_iter_is_closed_contour(
        iterator: *mut sk_path_iterator_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_iter_destroy"]
    pub fn sk_path_iter_destroy(iterator: *mut sk_path_iterator_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_path_create_rawiter"]
    pub fn sk_path_create_rawiter(cpath: *mut sk_path_t) -> *mut sk_path_rawiterator_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rawiter_peek"]
    pub fn sk_path_rawiter_peek(iterator: *mut sk_path_rawiterator_t) -> sk_path_verb_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rawiter_next"]
    pub fn sk_path_rawiter_next(
        iterator: *mut sk_path_rawiterator_t,
        points: *mut sk_point_t,
    ) -> sk_path_verb_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rawiter_conic_weight"]
    pub fn sk_path_rawiter_conic_weight(iterator: *mut sk_path_rawiterator_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_path_rawiter_destroy"]
    pub fn sk_path_rawiter_destroy(iterator: *mut sk_path_rawiterator_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_pathop_op"]
    pub fn sk_pathop_op(
        one: *const sk_path_t,
        two: *const sk_path_t,
        op: sk_pathop_t,
        result: *mut sk_path_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathop_simplify"]
    pub fn sk_pathop_simplify(path: *const sk_path_t, result: *mut sk_path_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathop_tight_bounds"]
    pub fn sk_pathop_tight_bounds(path: *const sk_path_t, result: *mut sk_rect_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_opbuilder_new"]
    pub fn sk_opbuilder_new() -> *mut sk_opbuilder_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_opbuilder_destroy"]
    pub fn sk_opbuilder_destroy(builder: *mut sk_opbuilder_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_opbuilder_add"]
    pub fn sk_opbuilder_add(builder: *mut sk_opbuilder_t, path: *const sk_path_t, op: sk_pathop_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_opbuilder_resolve"]
    pub fn sk_opbuilder_resolve(builder: *mut sk_opbuilder_t, result: *mut sk_path_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_new"]
    pub fn sk_pathmeasure_new() -> *mut sk_pathmeasure_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_new_with_path"]
    pub fn sk_pathmeasure_new_with_path(
        path: *const sk_path_t,
        forceClosed: bool,
        resScale: f32,
    ) -> *mut sk_pathmeasure_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_destroy"]
    pub fn sk_pathmeasure_destroy(pathMeasure: *mut sk_pathmeasure_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_set_path"]
    pub fn sk_pathmeasure_set_path(
        pathMeasure: *mut sk_pathmeasure_t,
        path: *const sk_path_t,
        forceClosed: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_get_length"]
    pub fn sk_pathmeasure_get_length(pathMeasure: *mut sk_pathmeasure_t) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_get_pos_tan"]
    pub fn sk_pathmeasure_get_pos_tan(
        pathMeasure: *mut sk_pathmeasure_t,
        distance: f32,
        position: *mut sk_point_t,
        tangent: *mut sk_vector_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_get_matrix"]
    pub fn sk_pathmeasure_get_matrix(
        pathMeasure: *mut sk_pathmeasure_t,
        distance: f32,
        matrix: *mut sk_matrix_t,
        flags: sk_pathmeasure_matrixflags_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_get_segment"]
    pub fn sk_pathmeasure_get_segment(
        pathMeasure: *mut sk_pathmeasure_t,
        start: f32,
        stop: f32,
        dst: *mut sk_path_t,
        startWithMoveTo: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_is_closed"]
    pub fn sk_pathmeasure_is_closed(pathMeasure: *mut sk_pathmeasure_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_pathmeasure_next_contour"]
    pub fn sk_pathmeasure_next_contour(pathMeasure: *mut sk_pathmeasure_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_recorder_new"]
    pub fn sk_picture_recorder_new() -> *mut sk_picture_recorder_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_recorder_delete"]
    pub fn sk_picture_recorder_delete(arg1: *mut sk_picture_recorder_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_recorder_begin_recording"]
    pub fn sk_picture_recorder_begin_recording(
        arg1: *mut sk_picture_recorder_t,
        arg2: *const sk_rect_t,
    ) -> *mut sk_canvas_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_recorder_end_recording"]
    pub fn sk_picture_recorder_end_recording(arg1: *mut sk_picture_recorder_t)
        -> *mut sk_picture_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_recorder_end_recording_as_drawable"]
    pub fn sk_picture_recorder_end_recording_as_drawable(
        arg1: *mut sk_picture_recorder_t,
    ) -> *mut sk_drawable_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_get_recording_canvas"]
    pub fn sk_picture_get_recording_canvas(crec: *mut sk_picture_recorder_t) -> *mut sk_canvas_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_ref"]
    pub fn sk_picture_ref(arg1: *mut sk_picture_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_unref"]
    pub fn sk_picture_unref(arg1: *mut sk_picture_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_get_unique_id"]
    pub fn sk_picture_get_unique_id(arg1: *mut sk_picture_t) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_sk_picture_get_cull_rect"]
    pub fn sk_picture_get_cull_rect(arg1: *mut sk_picture_t, arg2: *mut sk_rect_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_ref"]
    pub fn sk_shader_ref(arg1: *mut sk_shader_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_unref"]
    pub fn sk_shader_unref(arg1: *mut sk_shader_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_linear_gradient"]
    pub fn sk_shader_new_linear_gradient(
        points: *const sk_point_t,
        colors: *const sk_color_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_radial_gradient"]
    pub fn sk_shader_new_radial_gradient(
        center: *const sk_point_t,
        radius: f32,
        colors: *const sk_color_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_sweep_gradient"]
    pub fn sk_shader_new_sweep_gradient(
        center: *const sk_point_t,
        colors: *const sk_color_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        startAngle: f32,
        endAngle: f32,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_two_point_conical_gradient"]
    pub fn sk_shader_new_two_point_conical_gradient(
        start: *const sk_point_t,
        startRadius: f32,
        end: *const sk_point_t,
        endRadius: f32,
        colors: *const sk_color_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_empty"]
    pub fn sk_shader_new_empty() -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_color"]
    pub fn sk_shader_new_color(color: sk_color_t) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_bitmap"]
    pub fn sk_shader_new_bitmap(
        src: *const sk_bitmap_t,
        tmx: sk_shader_tilemode_t,
        tmy: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_picture"]
    pub fn sk_shader_new_picture(
        src: *mut sk_picture_t,
        tmx: sk_shader_tilemode_t,
        tmy: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
        tile: *const sk_rect_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_local_matrix"]
    pub fn sk_shader_new_local_matrix(
        proxy: *mut sk_shader_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_color_filter"]
    pub fn sk_shader_new_color_filter(
        proxy: *mut sk_shader_t,
        filter: *mut sk_colorfilter_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_perlin_noise_fractal_noise"]
    pub fn sk_shader_new_perlin_noise_fractal_noise(
        baseFrequencyX: f32,
        baseFrequencyY: f32,
        numOctaves: ::std::os::raw::c_int,
        seed: f32,
        tileSize: *const sk_isize_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_perlin_noise_turbulence"]
    pub fn sk_shader_new_perlin_noise_turbulence(
        baseFrequencyX: f32,
        baseFrequencyY: f32,
        numOctaves: ::std::os::raw::c_int,
        seed: f32,
        tileSize: *const sk_isize_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_compose"]
    pub fn sk_shader_new_compose(
        shaderA: *mut sk_shader_t,
        shaderB: *mut sk_shader_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_shader_new_compose_with_mode"]
    pub fn sk_shader_new_compose_with_mode(
        shaderA: *mut sk_shader_t,
        shaderB: *mut sk_shader_t,
        mode: sk_blendmode_t,
    ) -> *mut sk_shader_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_colortype_get_default_8888"]
    pub fn sk_colortype_get_default_8888() -> sk_colortype_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_new_null"]
    pub fn sk_surface_new_null(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut sk_surface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_new_raster"]
    pub fn sk_surface_new_raster(
        arg1: *const sk_imageinfo_t,
        rowBytes: usize,
        arg2: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_new_raster_direct"]
    pub fn sk_surface_new_raster_direct(
        arg1: *const sk_imageinfo_t,
        pixels: *mut ::std::os::raw::c_void,
        rowBytes: usize,
        releaseProc: sk_surface_raster_release_proc,
        context: *mut ::std::os::raw::c_void,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_new_backend_texture"]
    pub fn sk_surface_new_backend_texture(
        context: *mut gr_context_t,
        texture: *const gr_backendtexture_t,
        origin: gr_surfaceorigin_t,
        samples: ::std::os::raw::c_int,
        colorType: sk_colortype_t,
        colorspace: *mut sk_colorspace_t,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_new_backend_render_target"]
    pub fn sk_surface_new_backend_render_target(
        context: *mut gr_context_t,
        target: *const gr_backendrendertarget_t,
        origin: gr_surfaceorigin_t,
        colorType: sk_colortype_t,
        colorspace: *mut sk_colorspace_t,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_new_backend_texture_as_render_target"]
    pub fn sk_surface_new_backend_texture_as_render_target(
        context: *mut gr_context_t,
        texture: *const gr_backendtexture_t,
        origin: gr_surfaceorigin_t,
        samples: ::std::os::raw::c_int,
        colorType: sk_colortype_t,
        colorspace: *mut sk_colorspace_t,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_new_render_target"]
    pub fn sk_surface_new_render_target(
        context: *mut gr_context_t,
        budgeted: bool,
        cinfo: *const sk_imageinfo_t,
        sampleCount: ::std::os::raw::c_int,
        origin: gr_surfaceorigin_t,
        props: *const sk_surfaceprops_t,
        shouldCreateWithMips: bool,
    ) -> *mut sk_surface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_unref"]
    pub fn sk_surface_unref(arg1: *mut sk_surface_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_get_canvas"]
    pub fn sk_surface_get_canvas(arg1: *mut sk_surface_t) -> *mut sk_canvas_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_new_image_snapshot"]
    pub fn sk_surface_new_image_snapshot(arg1: *mut sk_surface_t) -> *mut sk_image_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_draw"]
    pub fn sk_surface_draw(
        surface: *mut sk_surface_t,
        canvas: *mut sk_canvas_t,
        x: f32,
        y: f32,
        paint: *const sk_paint_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_peek_pixels"]
    pub fn sk_surface_peek_pixels(surface: *mut sk_surface_t, pixmap: *mut sk_pixmap_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_read_pixels"]
    pub fn sk_surface_read_pixels(
        surface: *mut sk_surface_t,
        dstInfo: *mut sk_imageinfo_t,
        dstPixels: *mut ::std::os::raw::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_sk_surface_get_props"]
    pub fn sk_surface_get_props(surface: *mut sk_surface_t) -> *const sk_surfaceprops_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surfaceprops_new"]
    pub fn sk_surfaceprops_new(flags: u32, geometry: sk_pixelgeometry_t) -> *mut sk_surfaceprops_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_surfaceprops_delete"]
    pub fn sk_surfaceprops_delete(props: *mut sk_surfaceprops_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_surfaceprops_get_flags"]
    pub fn sk_surfaceprops_get_flags(props: *mut sk_surfaceprops_t) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_sk_surfaceprops_get_pixel_geometry"]
    pub fn sk_surfaceprops_get_pixel_geometry(props: *mut sk_surfaceprops_t) -> sk_pixelgeometry_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_create_default"]
    pub fn sk_typeface_create_default() -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_ref_default"]
    pub fn sk_typeface_ref_default() -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_create_from_name_with_font_style"]
    pub fn sk_typeface_create_from_name_with_font_style(
        familyName: *const ::std::os::raw::c_char,
        style: *mut sk_fontstyle_t,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_unref"]
    pub fn sk_typeface_unref(arg1: *mut sk_typeface_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_create_from_file"]
    pub fn sk_typeface_create_from_file(
        path: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_create_from_stream"]
    pub fn sk_typeface_create_from_stream(
        stream: *mut sk_stream_asset_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_chars_to_glyphs"]
    pub fn sk_typeface_chars_to_glyphs(
        typeface: *mut sk_typeface_t,
        chars: *const ::std::os::raw::c_char,
        encoding: sk_encoding_t,
        glyphs: *mut u16,
        glyphCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_open_stream"]
    pub fn sk_typeface_open_stream(
        typeface: *mut sk_typeface_t,
        ttcIndex: *mut ::std::os::raw::c_int,
    ) -> *mut sk_stream_asset_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_units_per_em"]
    pub fn sk_typeface_get_units_per_em(typeface: *mut sk_typeface_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_family_name"]
    pub fn sk_typeface_get_family_name(typeface: *mut sk_typeface_t) -> *mut sk_string_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_fontstyle"]
    pub fn sk_typeface_get_fontstyle(typeface: *mut sk_typeface_t) -> *mut sk_fontstyle_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_font_weight"]
    pub fn sk_typeface_get_font_weight(typeface: *mut sk_typeface_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_font_width"]
    pub fn sk_typeface_get_font_width(typeface: *mut sk_typeface_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_font_slant"]
    pub fn sk_typeface_get_font_slant(typeface: *mut sk_typeface_t) -> sk_font_style_slant_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_count_tables"]
    pub fn sk_typeface_count_tables(typeface: *mut sk_typeface_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_table_tags"]
    pub fn sk_typeface_get_table_tags(
        typeface: *mut sk_typeface_t,
        tags: *mut sk_font_table_tag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_table_size"]
    pub fn sk_typeface_get_table_size(
        typeface: *mut sk_typeface_t,
        tag: sk_font_table_tag_t,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_sk_typeface_get_table_data"]
    pub fn sk_typeface_get_table_data(
        typeface: *mut sk_typeface_t,
        tag: sk_font_table_tag_t,
        offset: usize,
        length: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_create_default"]
    pub fn sk_fontmgr_create_default() -> *mut sk_fontmgr_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_ref_default"]
    pub fn sk_fontmgr_ref_default() -> *mut sk_fontmgr_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_unref"]
    pub fn sk_fontmgr_unref(arg1: *mut sk_fontmgr_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_count_families"]
    pub fn sk_fontmgr_count_families(arg1: *mut sk_fontmgr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_get_family_name"]
    pub fn sk_fontmgr_get_family_name(
        arg1: *mut sk_fontmgr_t,
        index: ::std::os::raw::c_int,
        familyName: *mut sk_string_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_create_styleset"]
    pub fn sk_fontmgr_create_styleset(
        arg1: *mut sk_fontmgr_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_fontstyleset_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_match_family"]
    pub fn sk_fontmgr_match_family(
        arg1: *mut sk_fontmgr_t,
        familyName: *const ::std::os::raw::c_char,
    ) -> *mut sk_fontstyleset_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_match_family_style"]
    pub fn sk_fontmgr_match_family_style(
        arg1: *mut sk_fontmgr_t,
        familyName: *const ::std::os::raw::c_char,
        style: *mut sk_fontstyle_t,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_match_family_style_character"]
    pub fn sk_fontmgr_match_family_style_character(
        arg1: *mut sk_fontmgr_t,
        familyName: *const ::std::os::raw::c_char,
        style: *mut sk_fontstyle_t,
        bcp47: *mut *const ::std::os::raw::c_char,
        bcp47Count: ::std::os::raw::c_int,
        character: i32,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_match_face_style"]
    pub fn sk_fontmgr_match_face_style(
        arg1: *mut sk_fontmgr_t,
        face: *const sk_typeface_t,
        style: *mut sk_fontstyle_t,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_create_from_data"]
    pub fn sk_fontmgr_create_from_data(
        arg1: *mut sk_fontmgr_t,
        data: *mut sk_data_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_create_from_stream"]
    pub fn sk_fontmgr_create_from_stream(
        arg1: *mut sk_fontmgr_t,
        stream: *mut sk_stream_asset_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontmgr_create_from_file"]
    pub fn sk_fontmgr_create_from_file(
        arg1: *mut sk_fontmgr_t,
        path: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyle_new"]
    pub fn sk_fontstyle_new(
        weight: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        slant: sk_font_style_slant_t,
    ) -> *mut sk_fontstyle_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyle_delete"]
    pub fn sk_fontstyle_delete(fs: *mut sk_fontstyle_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyle_get_weight"]
    pub fn sk_fontstyle_get_weight(fs: *const sk_fontstyle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyle_get_width"]
    pub fn sk_fontstyle_get_width(fs: *const sk_fontstyle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyle_get_slant"]
    pub fn sk_fontstyle_get_slant(fs: *const sk_fontstyle_t) -> sk_font_style_slant_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyleset_create_empty"]
    pub fn sk_fontstyleset_create_empty() -> *mut sk_fontstyleset_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyleset_unref"]
    pub fn sk_fontstyleset_unref(fss: *mut sk_fontstyleset_t);
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyleset_get_count"]
    pub fn sk_fontstyleset_get_count(fss: *mut sk_fontstyleset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyleset_get_style"]
    pub fn sk_fontstyleset_get_style(
        fss: *mut sk_fontstyleset_t,
        index: ::std::os::raw::c_int,
        fs: *mut sk_fontstyle_t,
        style: *mut sk_string_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyleset_create_typeface"]
    pub fn sk_fontstyleset_create_typeface(
        fss: *mut sk_fontstyleset_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
}
extern "C" {
    #[link_name = "\u{1}_sk_fontstyleset_match_style"]
    pub fn sk_fontstyleset_match_style(
        fss: *mut sk_fontstyleset_t,
        style: *mut sk_fontstyle_t,
    ) -> *mut sk_typeface_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
